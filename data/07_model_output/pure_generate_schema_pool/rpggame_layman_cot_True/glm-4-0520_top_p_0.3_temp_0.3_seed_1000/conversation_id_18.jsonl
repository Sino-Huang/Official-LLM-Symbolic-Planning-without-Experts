{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the baking domain for demonstrating the output format.\n        \nDomain information: This describes a cooking or baking process where ingredients such as eggs and flour are used. The process of baking involves putting eggs in the pan followed by the flour, mix the two and then put the pan in the oven and then remove the pan from the oven to get the baked cake. Lastly, the pan is cleaned using a soap. Well, you can also bake a souffle but in at bit different process.\n\nA list of available predicates\n1. (is_egg ?egg - ingredient) ;; the ingredient is an egg\n2. (is_flour ?flour - ingredient) ;; the ingredient is flour\n3. (pan_has_egg ?pan - pan) ;; the pan has an egg\n4. (pan_has_flour ?pan - pan) ;; the pan has flour\n5. (pan_is_clean ?pan - pan) ;; the pan is clean\n6. (pan_in_oven ?pan - pan) ;; the pan is in the oven\n7. (in_pan ?x - ingredient ?pan - pan) ;; the ingredient is in the pan\n8. (in_oven ?pan - pan ?oven - oven) ;; the pan is in the oven\n9. (oven_is_full ?oven - oven) ;; the oven is full\n10. (hypothetical ?new - ingredient) ;; the ingredient is hypothetical\n11. (is_mixed ?pan - pan) ;; the ingredients in the pan are mixed\n12. (is_cake ?new - ingredient) ;; the ingredient is a cake\n13. (is_souffle ?new - ingredient) ;; the ingredient is a souffle\n14. (soap_consumed ?soap - soap) ;; the soap is consumed\nExample 1\nAction Description: This action is about taking a pan out of the oven. It can only be done if the pan is actually in the oven. Once the pan is removed, the oven is no longer considered full.\n\nAction name: remove_pan_from_oven\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's break down this action of removing a pan from the oven in a simple way.\n\nImagine you're baking a cake and you put your pan in the oven. Now, the oven is full because the pan is inside. At some point, you need to take the pan out of the oven when the cake is done. \n\nTo do this action of removing the pan, we need to make sure that the pan is actually in the oven first. This is the \"precondition\" \u2013 it's like a rule saying, \"You can only take the pan out if it's actually in there.\" It wouldn't make sense to try to take out a pan that isn't in the oven, right?\n\nOnce you take the pan out, several things happen, which we call \"effects\":\n1. The oven is no longer full because the pan is out.\n2. The pan is no longer in the oven.\n3. We also need to specifically say that the pan is not in the oven anymore.\n\nSo, the precondition (the rule that the pan must be in the oven) makes sure we can only do this action when it's appropriate. The effects describe what changes after we do the action. In this case, the oven is no longer full, and the pan is no longer in the oven. This helps us keep track of what's happening in our cooking process in a clear and logical way.\n                \n**Response:**\nParameters:\n1. ?oven - oven: [short description of the parameter]\n2. ?egg - ingredient: [short description of the parameter]\n3. ?pan - pan: [short description of the parameter]\n4. ?new - ingredient: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (in_pan ?egg ?pan)\n    (is_egg ?egg)\n    (not (pan_has_flour ?pan))\n    (in_oven ?pan ?oven)\n    (hypothetical ?new)\n)\n```\n\nEffects:\n```\n(and\n    (not (is_egg ?egg))\n    (not (in_pan ?egg ?pan))\n    (not (pan_has_egg ?pan))\n    (not (pan_is_clean ?pan))\n    (not (hypothetical ?new))\n    (is_souffle ?new)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: This action represents the process of making a souffle. It requires an egg in a pan (without flour), with the pan placed in an oven. A new, hypothetical ingredient is involved, which becomes a souffle as a result of this process. After baking, the pan is no longer clean.\n\nAction name: bake_souffle\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of making a souffle as if it were a little project where you need certain things to start, and you end up with something new at the end. In our souffle-making scenario, you begin with a pan, an egg, and an oven. This matches closely with our action schema in PDDL, named `bake_souffle`.\n\n1. **Preconditions:** \n    - **Egg in the Pan:** To make a souffle, the first thing you need is an egg in the pan. This matches the precondition `(in_pan ?egg ?pan)`, meaning the egg needs to be in the pan to start.\n    - **The Egg is Really an Egg:** We also need to confirm that what we're using is indeed an egg, so we check `(is_egg ?egg)`.\n    - **No Flour in the Pan:** For this particular recipe, having flour in the pan would mess things up, so the precondition `(not (pan_has_flour ?pan))` ensures flour isn't in the pan.\n    - **Pan in the Oven:** The pan must be in the oven `(in_oven ?pan ?oven)` for the baking to occur.\n    - **Hypothetical New Ingredient:** The schema mentions a `hypothetical ?new`, which represents the potential new ingredient, the souffle, that will be created.\n\n2. **Effects:**\n    - **Egg Transforms into Souffle:** After baking, the egg isn't just an egg anymore; it becomes a souffle. This is shown by `(not (is_egg ?egg))` and `(is_souffle ?new)`, where the egg disappears as an egg and reappears as a souffle.\n    - **Pan is No Longer Clean:** Baking usually leaves the pan dirty. Thus, the effect `(not (pan_is_clean ?pan))` captures this change.\n    - **Ingredients and Conditions Reset:** The egg is no longer in the pan, shown by `(not (in_pan ?egg ?pan))` and `(not (pan_has_egg ?pan))`, and the hypothetical nature of the new ingredient is removed with `(not (hypothetical ?new))`, finalizing the souffle's existence.\n\nSo, we start with an egg in a clean pan and finish with a baked souffle and a dirty pan. This schema captures all the steps and checks needed to go from start to finish in the souffle-making process, ensuring that each step and condition is accounted for, just like following a recipe!\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?oven - oven: [short description of the parameter]\n\nPreconditions:\n```\n(in_oven ?pan ?oven)\n```\n\nEffects:\n```\n(and\n    (not (oven_is_full ?oven))\n    (not (in_oven ?pan ?oven))\n    (not (pan_in_oven ?pan))\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: Help the hero to get out of dungeon! A hero woke up in a dungeon full of monsters and traps (perhaps the party last night went wrong...) and needs your help to get out.  Here are basic facts for the dungeon domain: - The dungeon contains rooms that are **connected** by corridors (dungeon can thus be represented by undirected graph) - each room can be **empty**, or can have a **monster** in it, or can have a **trap** in it, or can have a **sword** in it - one of the empty rooms is the **goal**: it has an exit, so the hero can escape\n\nA list of available predicates\n1. (at-hero ?loc - cells) ;;  Hero's cell location\n2. (at-sword ?s - swords ?loc - cells) ;; Sword cell location\n3. (has-monster ?loc - cells) ;; Indicates if a cell location has a monster\n4. (has-trap ?loc - cells) ;; Indicates if a cell location has a trap\n5. (is-destroyed ?obj) ;; Indicates if a chell or sword has been destroyed\n6. (connected ?from ?to - cells) ;; connects cells\n7. (arm-free) ;; Hero's hand is free\n8. (holding ?s - swords) ;; Hero's holding a sword\n9. (trap-disarmed ?loc) ;; It becomes true when a trap is disarmed\n\nAction Description: Hero can move if the - hero is at current location - cells are connected, - when this action is executed, the hero gets into a location with a monster\n\nAction name: move-to-monster\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the given dungeon domain, the hero needs to navigate through rooms connected by corridors to find an exit. The action `move-to-monster` describes a scenario where the hero moves from one room to another that contains a monster. For this action to be executed, certain conditions must be met, and certain outcomes must result from the action.\n\nThe preconditions ensure that the action is logically possible and meaningful within the context of the domain:\n- The hero must be at a specific location (`at-hero ?loc`).\n- The destination cell must be connected to the hero's current location (`connected ?from ?to`).\n- The destination cell must have a monster (`has-monster ?to`).\n\nThe effects describe the changes that occur in the world state as a result of the action:\n- The hero is no longer at the starting location (`not (at-hero ?from)`).\n- The hero is now at the destination location with the monster (`at-hero ?to`).\n\nThis action does not specify what happens to the monster when the hero moves to its location, so we assume that the hero simply moves into the room with the monster without any immediate interaction.\n\n**Response:**\nParameters:\n1. ?from - cells: [The cell where the hero is currently located]\n2. ?to - cells: [The cell with the monster that the hero is moving to]\n\nPreconditions:\n```\n(and\n    (at-hero ?from)\n    (connected ?from ?to)\n    (has-monster ?to)\n)\n```\n\nEffects:\n```\n(and\n    (not (at-hero ?from))\n    (at-hero ?to)\n)\n```\n\nNote: The above PDDL assumes that the hero's movement does not automatically trigger an encounter with the monster. If the domain rules state that moving to a cell with a monster results in an immediate encounter or battle, additional effects would need to be defined to reflect that outcome.", "type": "response", "action": "move-to-monster"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the baking domain for demonstrating the output format.\n        \nDomain information: This describes a cooking or baking process where ingredients such as eggs and flour are used. The process of baking involves putting eggs in the pan followed by the flour, mix the two and then put the pan in the oven and then remove the pan from the oven to get the baked cake. Lastly, the pan is cleaned using a soap. Well, you can also bake a souffle but in at bit different process.\n\nA list of available predicates\n1. (is_egg ?egg - ingredient) ;; the ingredient is an egg\n2. (is_flour ?flour - ingredient) ;; the ingredient is flour\n3. (pan_has_egg ?pan - pan) ;; the pan has an egg\n4. (pan_has_flour ?pan - pan) ;; the pan has flour\n5. (pan_is_clean ?pan - pan) ;; the pan is clean\n6. (pan_in_oven ?pan - pan) ;; the pan is in the oven\n7. (in_pan ?x - ingredient ?pan - pan) ;; the ingredient is in the pan\n8. (in_oven ?pan - pan ?oven - oven) ;; the pan is in the oven\n9. (oven_is_full ?oven - oven) ;; the oven is full\n10. (hypothetical ?new - ingredient) ;; the ingredient is hypothetical\n11. (is_mixed ?pan - pan) ;; the ingredients in the pan are mixed\n12. (is_cake ?new - ingredient) ;; the ingredient is a cake\n13. (is_souffle ?new - ingredient) ;; the ingredient is a souffle\n14. (soap_consumed ?soap - soap) ;; the soap is consumed\nExample 1\nAction Description: Cleaning a pan is the process of making a used pan clean again with the help of soap. It's possible only when the pan is not in the oven, and there is soap available to use. After cleaning, the pan is clean, and the soap is considered used up.\n\nAction name: clean_pan\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's break down why the action \"clean_pan\" has the specified preconditions and effects by imagining a simple scenario:\n\nImagine you have just baked a cake. The pan you used is now dirty, and you want to clean it so you can use it again. To do this, you need two things: the pan itself and some soap.\n\nFirst, let's talk about the preconditions, which are the things that need to be true before you can start cleaning the pan:\n\n1. **The soap must not be consumed**: This means you need to have soap that hasn't been used up yet. If your soap is already used up, you can't clean the pan because there wouldn't be anything to clean with.\n2. **The pan must not be in the oven**: If the pan is still in the oven, you can't clean it. You need to take it out first because you can only wash the pan when it's not inside the oven.\n\nNow, let's move on to the effects, which are the things that will be true after you clean the pan:\n\n1. **The pan will be clean**: After you wash the pan with soap, it becomes clean. This means you have successfully removed all the dirt and leftover cake from it.\n2. **The soap will be consumed**: After you use the soap to clean the pan, the soap gets used up. This means that you can't use the same soap again because it's already been consumed in the process of cleaning.\n\nSo, in simple terms, the preconditions ensure that you have soap available and the pan is accessible. The effects show the result of the cleaning process: a clean pan and used-up soap.\n\nBy setting these preconditions and effects, we can make sure that the action of cleaning the pan happens only when it makes sense and results in the correct outcome.\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?oven - oven: [short description of the parameter]\n\nPreconditions:\n```\n(in_oven ?pan ?oven)\n```\n\nEffects:\n```\n(and\n    (not (oven_is_full ?oven))\n    (not (in_oven ?pan ?oven))\n    (not (pan_in_oven ?pan))\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: This action is about taking a pan out of the oven. It can only be done if the pan is actually in the oven. Once the pan is removed, the oven is no longer considered full.\n\nAction name: remove_pan_from_oven\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's break down this action of removing a pan from the oven in a simple way.\n\nImagine you're baking a cake and you put your pan in the oven. Now, the oven is full because the pan is inside. At some point, you need to take the pan out of the oven when the cake is done. \n\nTo do this action of removing the pan, we need to make sure that the pan is actually in the oven first. This is the \"precondition\" \u2013 it's like a rule saying, \"You can only take the pan out if it's actually in there.\" It wouldn't make sense to try to take out a pan that isn't in the oven, right?\n\nOnce you take the pan out, several things happen, which we call \"effects\":\n1. The oven is no longer full because the pan is out.\n2. The pan is no longer in the oven.\n3. We also need to specifically say that the pan is not in the oven anymore.\n\nSo, the precondition (the rule that the pan must be in the oven) makes sure we can only do this action when it's appropriate. The effects describe what changes after we do the action. In this case, the oven is no longer full, and the pan is no longer in the oven. This helps us keep track of what's happening in our cooking process in a clear and logical way.\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?soap - soap: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (not (soap_consumed ?soap))\n    (not (pan_in_oven ?pan))\n)\n```\n\nEffects:\n```\n(and\n    (pan_is_clean ?pan)\n    (soap_consumed ?soap)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: Help the hero to get out of dungeon! A hero woke up in a dungeon full of monsters and traps (perhaps the party last night went wrong...) and needs your help to get out.  Here are basic facts for the dungeon domain: - The dungeon contains rooms that are **connected** by corridors (dungeon can thus be represented by undirected graph) - each room can be **empty**, or can have a **monster** in it, or can have a **trap** in it, or can have a **sword** in it - one of the empty rooms is the **goal**: it has an exit, so the hero can escape\n\nA list of available predicates\n1. (at-hero ?loc - cells) ;;  Hero's cell location\n2. (at-sword ?s - swords ?loc - cells) ;; Sword cell location\n3. (has-monster ?loc - cells) ;; Indicates if a cell location has a monster\n4. (has-trap ?loc - cells) ;; Indicates if a cell location has a trap\n5. (is-destroyed ?obj) ;; Indicates if a chell or sword has been destroyed\n6. (connected ?from ?to - cells) ;; connects cells\n7. (arm-free) ;; Hero's hand is free\n8. (holding ?s - swords) ;; Hero's holding a sword\n9. (trap-disarmed ?loc) ;; It becomes true when a trap is disarmed\n\nAction Description: Hero's disarm the trap with his hand. Make sure the hand is free.\n\nAction name: disarm-trap\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** In the given dungeon domain, the hero needs to navigate through rooms connected by corridors, avoiding or dealing with monsters and traps, and possibly picking up a sword to aid in their escape. The action \"disarm-trap\" is a critical step where the hero uses their hands to disable a trap in a room.\n\nFor this action to occur, certain conditions must be met (preconditions), and as a result of the action, certain changes will take place in the world state (effects).\n\nThe preconditions for disarming a trap are straightforward:\n1. The hero must be in the same room as the trap (`at-hero ?loc` and `has-trap ?loc`).\n2. The hero's hand must be free (`arm-free`). This is important because if the hero's hand is occupied (e.g., holding a sword), they cannot use it to disarm the trap.\n\nThe effects of disarming the trap are:\n1. The trap in the room is disarmed (`trap-disarmed ?loc`). This indicates that the trap no longer poses a threat to the hero.\n\nIt's important to note that the action does not specify what happens to the trap after it is disarmed (e.g., whether it is destroyed or simply becomes inactive), so we will not include an effect that changes the trap's destroyed state unless specified.\n\n**Response:**\nParameters:\n1. ?loc - cells: [The cell where the hero is located and where the trap is located]\n\nPreconditions:\n```\n(and\n    (at-hero ?loc)\n    (has-trap ?loc)\n    (arm-free)\n)\n```\n\nEffects:\n```\n(and\n    (trap-disarmed ?loc)\n)\n```\n\nThis PDDL action schema ensures that the hero can only disarm a trap if they are in the correct location, the trap exists there, and their hand is free to do so. After the action, the trap is disarmed, allowing the hero to safely continue their escape.", "type": "response", "action": "disarm-trap"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery wants to deliver the newspaper to a house (loc_house1).\nRoboDelivery performs the move action to go from loc_home to loc_house1.\n\n    Preconditions: RoboDelivery is at loc_home.\n    Effects: RoboDelivery is no longer at loc_home and is now at loc_house1.\n\nAction name: move\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're playing a game where you need to deliver newspapers to different houses in your neighborhood. Each turn in the game allows you to move from one house to another. The action of moving from one house to another in the game can be compared to an action in our newspaper delivery model.\n\nIn the scenario, the action is called \"move,\" and it involves a delivery person moving from a starting location to a destination. Let's break down why this action is modeled the way it is:\n\n1. **Parameters**: These are like placeholders or markers in our game. In the \"move\" action, the parameters are the Starting Location and the Destination. It's just like saying, \"I'm starting from my house and going to my friend's house.\"\n\n2. **Preconditions**: Before you can move from one house to another, you must be at the house you're starting from. It wouldn't make sense to say, \"I'm going from my house to my friend's house\" if you're actually at the grocery store, right? So, the precondition that the delivery person is at the starting location is crucial to make the action logical.\n\n3. **Effects**: After you move from your house to your friend's house, you are no longer at your house; you are now at your friend's house. That\u2019s what happens in our model, too. The effect of the move action is that the delivery person is no longer at the starting location and is now at the destination. This change is captured in the model by removing the state of being at the starting location (`not (at ?from)`) and adding the state of being at the destination (`(at ?to)`).\n\nSo, this action schema perfectly represents the simple yet essential task of moving from one point to another, ensuring that the game's rules are followed: you start from where you say you are, and you end up where you want to go. It's just like moving pieces on a board game, ensuring each move is valid based on where you are and where you want to be.\n                \n**Response:**\nParameters:\n1. ?from - loc: [short description of the parameter]\n2. ?to - loc: [short description of the parameter]\n\nPreconditions:\n```\n(at ?from)\n```\n\nEffects:\n```\n(and\n    (not (at ?from))\n    (at ?to)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the baking domain for demonstrating the output format.\n        \nDomain information: This describes a cooking or baking process where ingredients such as eggs and flour are used. The process of baking involves putting eggs in the pan followed by the flour, mix the two and then put the pan in the oven and then remove the pan from the oven to get the baked cake. Lastly, the pan is cleaned using a soap. Well, you can also bake a souffle but in at bit different process.\n\nA list of available predicates\n1. (is_egg ?egg - ingredient) ;; the ingredient is an egg\n2. (is_flour ?flour - ingredient) ;; the ingredient is flour\n3. (pan_has_egg ?pan - pan) ;; the pan has an egg\n4. (pan_has_flour ?pan - pan) ;; the pan has flour\n5. (pan_is_clean ?pan - pan) ;; the pan is clean\n6. (pan_in_oven ?pan - pan) ;; the pan is in the oven\n7. (in_pan ?x - ingredient ?pan - pan) ;; the ingredient is in the pan\n8. (in_oven ?pan - pan ?oven - oven) ;; the pan is in the oven\n9. (oven_is_full ?oven - oven) ;; the oven is full\n10. (hypothetical ?new - ingredient) ;; the ingredient is hypothetical\n11. (is_mixed ?pan - pan) ;; the ingredients in the pan are mixed\n12. (is_cake ?new - ingredient) ;; the ingredient is a cake\n13. (is_souffle ?new - ingredient) ;; the ingredient is a souffle\n14. (soap_consumed ?soap - soap) ;; the soap is consumed\nExample 1\nAction Description: This action is about taking a pan out of the oven. It can only be done if the pan is actually in the oven. Once the pan is removed, the oven is no longer considered full.\n\nAction name: remove_pan_from_oven\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's break down this action of removing a pan from the oven in a simple way.\n\nImagine you're baking a cake and you put your pan in the oven. Now, the oven is full because the pan is inside. At some point, you need to take the pan out of the oven when the cake is done. \n\nTo do this action of removing the pan, we need to make sure that the pan is actually in the oven first. This is the \"precondition\" \u2013 it's like a rule saying, \"You can only take the pan out if it's actually in there.\" It wouldn't make sense to try to take out a pan that isn't in the oven, right?\n\nOnce you take the pan out, several things happen, which we call \"effects\":\n1. The oven is no longer full because the pan is out.\n2. The pan is no longer in the oven.\n3. We also need to specifically say that the pan is not in the oven anymore.\n\nSo, the precondition (the rule that the pan must be in the oven) makes sure we can only do this action when it's appropriate. The effects describe what changes after we do the action. In this case, the oven is no longer full, and the pan is no longer in the oven. This helps us keep track of what's happening in our cooking process in a clear and logical way.\n                \n**Response:**\nParameters:\n1. ?oven - oven: [short description of the parameter]\n2. ?egg - ingredient: [short description of the parameter]\n3. ?pan - pan: [short description of the parameter]\n4. ?new - ingredient: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (in_pan ?egg ?pan)\n    (is_egg ?egg)\n    (not (pan_has_flour ?pan))\n    (in_oven ?pan ?oven)\n    (hypothetical ?new)\n)\n```\n\nEffects:\n```\n(and\n    (not (is_egg ?egg))\n    (not (in_pan ?egg ?pan))\n    (not (pan_has_egg ?pan))\n    (not (pan_is_clean ?pan))\n    (not (hypothetical ?new))\n    (is_souffle ?new)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: This action represents the process of making a souffle. It requires an egg in a pan (without flour), with the pan placed in an oven. A new, hypothetical ingredient is involved, which becomes a souffle as a result of this process. After baking, the pan is no longer clean.\n\nAction name: bake_souffle\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of making a souffle as if it were a little project where you need certain things to start, and you end up with something new at the end. In our souffle-making scenario, you begin with a pan, an egg, and an oven. This matches closely with our action schema in PDDL, named `bake_souffle`.\n\n1. **Preconditions:** \n    - **Egg in the Pan:** To make a souffle, the first thing you need is an egg in the pan. This matches the precondition `(in_pan ?egg ?pan)`, meaning the egg needs to be in the pan to start.\n    - **The Egg is Really an Egg:** We also need to confirm that what we're using is indeed an egg, so we check `(is_egg ?egg)`.\n    - **No Flour in the Pan:** For this particular recipe, having flour in the pan would mess things up, so the precondition `(not (pan_has_flour ?pan))` ensures flour isn't in the pan.\n    - **Pan in the Oven:** The pan must be in the oven `(in_oven ?pan ?oven)` for the baking to occur.\n    - **Hypothetical New Ingredient:** The schema mentions a `hypothetical ?new`, which represents the potential new ingredient, the souffle, that will be created.\n\n2. **Effects:**\n    - **Egg Transforms into Souffle:** After baking, the egg isn't just an egg anymore; it becomes a souffle. This is shown by `(not (is_egg ?egg))` and `(is_souffle ?new)`, where the egg disappears as an egg and reappears as a souffle.\n    - **Pan is No Longer Clean:** Baking usually leaves the pan dirty. Thus, the effect `(not (pan_is_clean ?pan))` captures this change.\n    - **Ingredients and Conditions Reset:** The egg is no longer in the pan, shown by `(not (in_pan ?egg ?pan))` and `(not (pan_has_egg ?pan))`, and the hypothetical nature of the new ingredient is removed with `(not (hypothetical ?new))`, finalizing the souffle's existence.\n\nSo, we start with an egg in a clean pan and finish with a baked souffle and a dirty pan. This schema captures all the steps and checks needed to go from start to finish in the souffle-making process, ensuring that each step and condition is accounted for, just like following a recipe!\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?oven - oven: [short description of the parameter]\n\nPreconditions:\n```\n(in_oven ?pan ?oven)\n```\n\nEffects:\n```\n(and\n    (not (oven_is_full ?oven))\n    (not (in_oven ?pan ?oven))\n    (not (pan_in_oven ?pan))\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: Help the hero to get out of dungeon! A hero woke up in a dungeon full of monsters and traps (perhaps the party last night went wrong...) and needs your help to get out.  Here are basic facts for the dungeon domain: - The dungeon contains rooms that are **connected** by corridors (dungeon can thus be represented by undirected graph) - each room can be **empty**, or can have a **monster** in it, or can have a **trap** in it, or can have a **sword** in it - one of the empty rooms is the **goal**: it has an exit, so the hero can escape\n\nA list of available predicates\n1. (at-hero ?loc - cells) ;;  Hero's cell location\n2. (at-sword ?s - swords ?loc - cells) ;; Sword cell location\n3. (has-monster ?loc - cells) ;; Indicates if a cell location has a monster\n4. (has-trap ?loc - cells) ;; Indicates if a cell location has a trap\n5. (is-destroyed ?obj) ;; Indicates if a chell or sword has been destroyed\n6. (connected ?from ?to - cells) ;; connects cells\n7. (arm-free) ;; Hero's hand is free\n8. (holding ?s - swords) ;; Hero's holding a sword\n9. (trap-disarmed ?loc) ;; It becomes true when a trap is disarmed\n\nAction Description: Hero's picks a sword if he's in the same location\n\nAction name: pick-sword\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the given dungeon domain, the hero needs to navigate through rooms connected by corridors, avoiding monsters and traps, and possibly picking up a sword to aid in their escape. The action \"pick-sword\" represents the hero taking a sword from a room they are currently in.\n\nFor this action to occur, certain conditions must be met (preconditions):\n- The hero must be in the same location as the sword (`(at-hero ?loc)` and `(at-sword ?s ?loc)`).\n- The hero's hand must be free to pick up the sword (`(arm-free)`).\n\nOnce the hero picks up the sword, the state of the world changes (effects):\n- The hero is no longer free-handed but is now holding the sword (`(not (arm-free))` and `(holding ?s)`).\n- The sword is no longer in its original location (`(not (at-sword ?s ?loc))`).\n\nThis action schema ensures that the hero can only pick up a sword if they are in the same room as the sword and if their hand is free, which makes logical sense in the context of the game.\n\n**Response:**\nParameters:\n1. ?s - swords: [The sword that the hero is going to pick up]\n2. ?loc - cells: [The location where the hero and the sword are]\n\nPreconditions:\n```\n(and\n    (at-hero ?loc)\n    (at-sword ?s ?loc)\n    (arm-free)\n)\n```\n\nEffects:\n```\n(and\n    (not (arm-free))\n    (holding ?s)\n    (not (at-sword ?s ?loc))\n)\n```", "type": "response", "action": "pick-sword"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the baking domain for demonstrating the output format.\n        \nDomain information: This describes a cooking or baking process where ingredients such as eggs and flour are used. The process of baking involves putting eggs in the pan followed by the flour, mix the two and then put the pan in the oven and then remove the pan from the oven to get the baked cake. Lastly, the pan is cleaned using a soap. Well, you can also bake a souffle but in at bit different process.\n\nA list of available predicates\n1. (is_egg ?egg - ingredient) ;; the ingredient is an egg\n2. (is_flour ?flour - ingredient) ;; the ingredient is flour\n3. (pan_has_egg ?pan - pan) ;; the pan has an egg\n4. (pan_has_flour ?pan - pan) ;; the pan has flour\n5. (pan_is_clean ?pan - pan) ;; the pan is clean\n6. (pan_in_oven ?pan - pan) ;; the pan is in the oven\n7. (in_pan ?x - ingredient ?pan - pan) ;; the ingredient is in the pan\n8. (in_oven ?pan - pan ?oven - oven) ;; the pan is in the oven\n9. (oven_is_full ?oven - oven) ;; the oven is full\n10. (hypothetical ?new - ingredient) ;; the ingredient is hypothetical\n11. (is_mixed ?pan - pan) ;; the ingredients in the pan are mixed\n12. (is_cake ?new - ingredient) ;; the ingredient is a cake\n13. (is_souffle ?new - ingredient) ;; the ingredient is a souffle\n14. (soap_consumed ?soap - soap) ;; the soap is consumed\nExample 1\nAction Description: Baking a cake involves transforming mixed ingredients in a pan into a cake. This action is possible when the ingredients in the pan are mixed, the pan is in the oven, and it involves creating a new type of ingredient, termed here as hypothetical. The end result is a cake, and the pan becomes dirty.\n\nAction name: bake_cake\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** The action schema for \"bake_cake\" describes the steps needed to transform a pan of mixed ingredients into a cake. Let\u2019s break down why each part is necessary.\n\nImagine you are in the kitchen with a bowl (the pan) filled with mixed ingredients. To bake a cake, you need to follow specific steps and meet certain conditions:\n\n1. **Preconditions:** \n   - **(is_mixed ?pan):** This means that the ingredients in the pan must already be mixed. Think about it: if you don\u2019t mix the flour and eggs together, they won\u2019t turn into a cake. So, the first condition is that the mixture is ready.\n   - **(in_oven ?pan ?oven):** The pan must be inside the oven. If it\u2019s not in the oven, baking can\u2019t happen. Just like you can't bake a cake if you leave the pan on the counter.\n   - **(hypothetical ?new):** This indicates that you are about to create something new, which in this case is the cake. It\u2019s like saying we have the potential to make a cake.\n\n2. **Effects:**\n   - **(not (is_mixed ?pan)):** Once you bake the cake, the ingredients are no longer just mixed; they have transformed into a cake. So, this condition removes the state of being mixed.\n   - **(not (pan_is_clean ?pan)):** After baking, the pan becomes dirty. This effect shows that the pan is no longer clean because it was used for baking.\n   - **(not (hypothetical ?new)):** Now that the cake is baked, it\u2019s no longer a hypothetical possibility but an actual cake.\n   - **(is_cake ?new):** This confirms that what you now have is indeed a cake.\n\nIn summary, the preconditions ensure that you have mixed ingredients in the oven, ready to be baked. The effects describe the outcome: the ingredients are no longer just mixed, the pan is dirty from baking, and the hypothetical idea of a cake has turned into a real cake. This process is like following a recipe step-by-step to ensure everything is done correctly to bake a cake.\n                \n**Response:**\nParameters:\n1. ?oven - oven: [short description of the parameter]\n2. ?pan - pan: [short description of the parameter]\n3. ?new - ingredient: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (is_mixed ?pan)\n    (in_oven ?pan ?oven)\n    (hypothetical ?new)\n)\n```\n\nEffects:\n```\n(and\n    (not (is_mixed ?pan))\n    (not (pan_is_clean ?pan))\n    (not (hypothetical ?new))\n    (is_cake ?new)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: This action represents the process of making a souffle. It requires an egg in a pan (without flour), with the pan placed in an oven. A new, hypothetical ingredient is involved, which becomes a souffle as a result of this process. After baking, the pan is no longer clean.\n\nAction name: bake_souffle\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of making a souffle as if it were a little project where you need certain things to start, and you end up with something new at the end. In our souffle-making scenario, you begin with a pan, an egg, and an oven. This matches closely with our action schema in PDDL, named `bake_souffle`.\n\n1. **Preconditions:** \n    - **Egg in the Pan:** To make a souffle, the first thing you need is an egg in the pan. This matches the precondition `(in_pan ?egg ?pan)`, meaning the egg needs to be in the pan to start.\n    - **The Egg is Really an Egg:** We also need to confirm that what we're using is indeed an egg, so we check `(is_egg ?egg)`.\n    - **No Flour in the Pan:** For this particular recipe, having flour in the pan would mess things up, so the precondition `(not (pan_has_flour ?pan))` ensures flour isn't in the pan.\n    - **Pan in the Oven:** The pan must be in the oven `(in_oven ?pan ?oven)` for the baking to occur.\n    - **Hypothetical New Ingredient:** The schema mentions a `hypothetical ?new`, which represents the potential new ingredient, the souffle, that will be created.\n\n2. **Effects:**\n    - **Egg Transforms into Souffle:** After baking, the egg isn't just an egg anymore; it becomes a souffle. This is shown by `(not (is_egg ?egg))` and `(is_souffle ?new)`, where the egg disappears as an egg and reappears as a souffle.\n    - **Pan is No Longer Clean:** Baking usually leaves the pan dirty. Thus, the effect `(not (pan_is_clean ?pan))` captures this change.\n    - **Ingredients and Conditions Reset:** The egg is no longer in the pan, shown by `(not (in_pan ?egg ?pan))` and `(not (pan_has_egg ?pan))`, and the hypothetical nature of the new ingredient is removed with `(not (hypothetical ?new))`, finalizing the souffle's existence.\n\nSo, we start with an egg in a clean pan and finish with a baked souffle and a dirty pan. This schema captures all the steps and checks needed to go from start to finish in the souffle-making process, ensuring that each step and condition is accounted for, just like following a recipe!\n                \n**Response:**\nParameters:\n1. ?oven - oven: [short description of the parameter]\n2. ?egg - ingredient: [short description of the parameter]\n3. ?pan - pan: [short description of the parameter]\n4. ?new - ingredient: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (in_pan ?egg ?pan)\n    (is_egg ?egg)\n    (not (pan_has_flour ?pan))\n    (in_oven ?pan ?oven)\n    (hypothetical ?new)\n)\n```\n\nEffects:\n```\n(and\n    (not (is_egg ?egg))\n    (not (in_pan ?egg ?pan))\n    (not (pan_has_egg ?pan))\n    (not (pan_is_clean ?pan))\n    (not (hypothetical ?new))\n    (is_souffle ?new)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: Help the hero to get out of dungeon! A hero woke up in a dungeon full of monsters and traps (perhaps the party last night went wrong...) and needs your help to get out.  Here are basic facts for the dungeon domain: - The dungeon contains rooms that are **connected** by corridors (dungeon can thus be represented by undirected graph) - each room can be **empty**, or can have a **monster** in it, or can have a **trap** in it, or can have a **sword** in it - one of the empty rooms is the **goal**: it has an exit, so the hero can escape\n\nA list of available predicates\n1. (at-hero ?loc - cells) ;;  Hero's cell location\n2. (at-sword ?s - swords ?loc - cells) ;; Sword cell location\n3. (has-monster ?loc - cells) ;; Indicates if a cell location has a monster\n4. (has-trap ?loc - cells) ;; Indicates if a cell location has a trap\n5. (is-destroyed ?obj) ;; Indicates if a chell or sword has been destroyed\n6. (connected ?from ?to - cells) ;; connects cells\n7. (arm-free) ;; Hero's hand is free\n8. (holding ?s - swords) ;; Hero's holding a sword\n9. (trap-disarmed ?loc) ;; It becomes true when a trap is disarmed\n\nAction Description: Hero can move if the - hero is at current location - cells are connected, - when this action is executed, the hero gets into a location with a trap\n\nAction name: move-to-trap\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the given dungeon domain, the hero needs to navigate through rooms connected by corridors to find an exit. The action `move-to-trap` describes a scenario where the hero moves from one room to another that contains a trap. For this action to be executed, certain conditions must be met, and certain changes to the world state should occur once the action is completed.\n\nThe preconditions for the `move-to-trap` action ensure that:\n- The hero is currently in a location (`at-hero ?loc`).\n- The hero's destination is a connected location (`connected ?from ?to`), meaning there is a corridor linking the current location to the destination.\n- The destination location has a trap (`has-trap ?to`), which is the condition that defines the action as moving specifically to a trap.\n\nThe effects of the action describe what changes as a result of the hero moving:\n- The hero's location changes from the starting location to the destination with the trap (`at-hero ?to`), which implies that the hero is no longer at the starting location (`not (at-hero ?from)`).\n\nNote that the action does not specify what happens to the trap itself; it only describes the movement of the hero to a location with a trap. Therefore, we do not include any effects related to the trap being disarmed or not.\n\n**Response:**\nParameters:\n1. ?from - cells: [The starting cell location of the hero]\n2. ?to - cells: [The destination cell location with a trap]\n\nPreconditions:\n```\n(and\n    (at-hero ?from)\n    (connected ?from ?to)\n    (has-trap ?to)\n)\n```\n\nEffects:\n```\n(and\n    (not (at-hero ?from))\n    (at-hero ?to)\n)\n```\n\n---\n", "type": "response", "action": "move-to-trap"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?from - loc: [short description of the parameter]\n2. ?to - loc: [short description of the parameter]\n\nPreconditions:\n```\n(at ?from)\n```\n\nEffects:\n```\n(and\n    (not (at ?from))\n    (at ?to)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery wants to deliver the newspaper to a house (loc_house1).\nRoboDelivery performs the move action to go from loc_home to loc_house1.\n\n    Preconditions: RoboDelivery is at loc_home.\n    Effects: RoboDelivery is no longer at loc_home and is now at loc_house1.\n\nAction name: move\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're playing a game where you need to deliver newspapers to different houses in your neighborhood. Each turn in the game allows you to move from one house to another. The action of moving from one house to another in the game can be compared to an action in our newspaper delivery model.\n\nIn the scenario, the action is called \"move,\" and it involves a delivery person moving from a starting location to a destination. Let's break down why this action is modeled the way it is:\n\n1. **Parameters**: These are like placeholders or markers in our game. In the \"move\" action, the parameters are the Starting Location and the Destination. It's just like saying, \"I'm starting from my house and going to my friend's house.\"\n\n2. **Preconditions**: Before you can move from one house to another, you must be at the house you're starting from. It wouldn't make sense to say, \"I'm going from my house to my friend's house\" if you're actually at the grocery store, right? So, the precondition that the delivery person is at the starting location is crucial to make the action logical.\n\n3. **Effects**: After you move from your house to your friend's house, you are no longer at your house; you are now at your friend's house. That\u2019s what happens in our model, too. The effect of the move action is that the delivery person is no longer at the starting location and is now at the destination. This change is captured in the model by removing the state of being at the starting location (`not (at ?from)`) and adding the state of being at the destination (`(at ?to)`).\n\nSo, this action schema perfectly represents the simple yet essential task of moving from one point to another, ensuring that the game's rules are followed: you start from where you say you are, and you end up where you want to go. It's just like moving pieces on a board game, ensuring each move is valid based on where you are and where you want to be.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the baking domain for demonstrating the output format.\n        \nDomain information: This describes a cooking or baking process where ingredients such as eggs and flour are used. The process of baking involves putting eggs in the pan followed by the flour, mix the two and then put the pan in the oven and then remove the pan from the oven to get the baked cake. Lastly, the pan is cleaned using a soap. Well, you can also bake a souffle but in at bit different process.\n\nA list of available predicates\n1. (is_egg ?egg - ingredient) ;; the ingredient is an egg\n2. (is_flour ?flour - ingredient) ;; the ingredient is flour\n3. (pan_has_egg ?pan - pan) ;; the pan has an egg\n4. (pan_has_flour ?pan - pan) ;; the pan has flour\n5. (pan_is_clean ?pan - pan) ;; the pan is clean\n6. (pan_in_oven ?pan - pan) ;; the pan is in the oven\n7. (in_pan ?x - ingredient ?pan - pan) ;; the ingredient is in the pan\n8. (in_oven ?pan - pan ?oven - oven) ;; the pan is in the oven\n9. (oven_is_full ?oven - oven) ;; the oven is full\n10. (hypothetical ?new - ingredient) ;; the ingredient is hypothetical\n11. (is_mixed ?pan - pan) ;; the ingredients in the pan are mixed\n12. (is_cake ?new - ingredient) ;; the ingredient is a cake\n13. (is_souffle ?new - ingredient) ;; the ingredient is a souffle\n14. (soap_consumed ?soap - soap) ;; the soap is consumed\nExample 1\nAction Description: This action involves placing a pan inside an oven. It is only possible if the oven isn't already full and the pan isn't in the oven. When the pan is placed in the oven, the oven becomes full.\n\nAction name: put_pan_in_oven\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's imagine we're in a kitchen, and we want to bake a cake. One of the steps is to put the pan with our ingredients into the oven. Before we can do that, we need to make sure of a couple of things:\n\n1. **The oven isn't full**: This is like checking if there's enough space in the oven. If the oven is already full, we can't put another pan inside. So, the first condition is that the oven must not be full.\n\n2. **The pan isn't already in the oven**: This ensures that we're not trying to put the same pan in the oven again if it's already there. It would be silly to try to put a pan in the oven that's already inside, right?\n\nWhen these two conditions are met, we can go ahead with our action. \n\nOnce we place the pan in the oven, three things happen:\n\n1. **The oven becomes full**: Since we've put something in the oven, it now counts as being full, preventing us from adding more until we make space.\n\n2. **The pan is now inside the oven**: This shows that our action was successful, and the pan is in the right place for baking.\n\n3. **The pan is considered to be in the oven**: This is another way of confirming that our pan is where it should be, in the oven.\n\nSo, by making sure the oven isn't full and the pan isn't already inside, we can successfully place the pan in the oven, leading to these effects.\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?oven - oven: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (not (oven_is_full ?oven))\n    (not (pan_in_oven ?pan))\n)\n```\n\nEffects:\n```\n(and\n    (oven_is_full ?oven)\n    (in_oven ?pan ?oven)\n    (pan_in_oven ?pan)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: Cleaning a pan is the process of making a used pan clean again with the help of soap. It's possible only when the pan is not in the oven, and there is soap available to use. After cleaning, the pan is clean, and the soap is considered used up.\n\nAction name: clean_pan\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's break down why the action \"clean_pan\" has the specified preconditions and effects by imagining a simple scenario:\n\nImagine you have just baked a cake. The pan you used is now dirty, and you want to clean it so you can use it again. To do this, you need two things: the pan itself and some soap.\n\nFirst, let's talk about the preconditions, which are the things that need to be true before you can start cleaning the pan:\n\n1. **The soap must not be consumed**: This means you need to have soap that hasn't been used up yet. If your soap is already used up, you can't clean the pan because there wouldn't be anything to clean with.\n2. **The pan must not be in the oven**: If the pan is still in the oven, you can't clean it. You need to take it out first because you can only wash the pan when it's not inside the oven.\n\nNow, let's move on to the effects, which are the things that will be true after you clean the pan:\n\n1. **The pan will be clean**: After you wash the pan with soap, it becomes clean. This means you have successfully removed all the dirt and leftover cake from it.\n2. **The soap will be consumed**: After you use the soap to clean the pan, the soap gets used up. This means that you can't use the same soap again because it's already been consumed in the process of cleaning.\n\nSo, in simple terms, the preconditions ensure that you have soap available and the pan is accessible. The effects show the result of the cleaning process: a clean pan and used-up soap.\n\nBy setting these preconditions and effects, we can make sure that the action of cleaning the pan happens only when it makes sense and results in the correct outcome.\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?soap - soap: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (not (soap_consumed ?soap))\n    (not (pan_in_oven ?pan))\n)\n```\n\nEffects:\n```\n(and\n    (pan_is_clean ?pan)\n    (soap_consumed ?soap)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: Help the hero to get out of dungeon! A hero woke up in a dungeon full of monsters and traps (perhaps the party last night went wrong...) and needs your help to get out.  Here are basic facts for the dungeon domain: - The dungeon contains rooms that are **connected** by corridors (dungeon can thus be represented by undirected graph) - each room can be **empty**, or can have a **monster** in it, or can have a **trap** in it, or can have a **sword** in it - one of the empty rooms is the **goal**: it has an exit, so the hero can escape\n\nA list of available predicates\n1. (at-hero ?loc - cells) ;;  Hero's cell location\n2. (at-sword ?s - swords ?loc - cells) ;; Sword cell location\n3. (has-monster ?loc - cells) ;; Indicates if a cell location has a monster\n4. (has-trap ?loc - cells) ;; Indicates if a cell location has a trap\n5. (is-destroyed ?obj) ;; Indicates if a chell or sword has been destroyed\n6. (connected ?from ?to - cells) ;; connects cells\n7. (arm-free) ;; Hero's hand is free\n8. (holding ?s - swords) ;; Hero's holding a sword\n9. (trap-disarmed ?loc) ;; It becomes true when a trap is disarmed\n\nAction Description: Hero's destroys his sword. So that he is arm-free and can disarm traps in the future if required. \n\nAction name: destroy-sword\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** In the dungeon domain, the hero may find it necessary to destroy his sword for various reasons, such as needing to be arm-free to disarm traps. The action \"destroy-sword\" represents this decision. Before the hero can perform this action, there are certain conditions that must be met, and the action will have specific consequences.\n\nThe preconditions for the action \"destroy-sword\" are:\n\n1. The hero must be holding a sword. It wouldn't make sense to destroy a sword if the hero isn't already carrying one.\n\nThe effects of the action \"destroy-sword\" are:\n\n1. The hero becomes arm-free, which means his hands are no longer occupied by the sword, allowing him to perform other actions like disarming traps.\n2. The sword that the hero was holding is now destroyed, which means it can no longer be used or held.\n\nThis action does not specify the location of the hero or the sword since the destruction of the sword is independent of the hero's location. It only requires that the hero is holding the sword before he destroys it.\n\n**Response:**\nParameters:\n1. ?s - swords: [The sword that the hero is going to destroy]\n\nPreconditions:\n```\n(and\n    (holding ?s)\n)\n```\n\nEffects:\n```\n(and\n    (not (holding ?s))\n    (arm-free)\n    (is-destroyed ?s)\n)\n```\n\n---", "type": "response", "action": "destroy-sword"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery wants to deliver the newspaper to a house (loc_house1).\nRoboDelivery performs the move action to go from loc_home to loc_house1.\n\n    Preconditions: RoboDelivery is at loc_home.\n    Effects: RoboDelivery is no longer at loc_home and is now at loc_house1.\n\nAction name: move\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're playing a game where you need to deliver newspapers to different houses in your neighborhood. Each turn in the game allows you to move from one house to another. The action of moving from one house to another in the game can be compared to an action in our newspaper delivery model.\n\nIn the scenario, the action is called \"move,\" and it involves a delivery person moving from a starting location to a destination. Let's break down why this action is modeled the way it is:\n\n1. **Parameters**: These are like placeholders or markers in our game. In the \"move\" action, the parameters are the Starting Location and the Destination. It's just like saying, \"I'm starting from my house and going to my friend's house.\"\n\n2. **Preconditions**: Before you can move from one house to another, you must be at the house you're starting from. It wouldn't make sense to say, \"I'm going from my house to my friend's house\" if you're actually at the grocery store, right? So, the precondition that the delivery person is at the starting location is crucial to make the action logical.\n\n3. **Effects**: After you move from your house to your friend's house, you are no longer at your house; you are now at your friend's house. That\u2019s what happens in our model, too. The effect of the move action is that the delivery person is no longer at the starting location and is now at the destination. This change is captured in the model by removing the state of being at the starting location (`not (at ?from)`) and adding the state of being at the destination (`(at ?to)`).\n\nSo, this action schema perfectly represents the simple yet essential task of moving from one point to another, ensuring that the game's rules are followed: you start from where you say you are, and you end up where you want to go. It's just like moving pieces on a board game, ensuring each move is valid based on where you are and where you want to be.\n                \n**Response:**\nParameters:\n1. ?from - loc: [short description of the parameter]\n2. ?to - loc: [short description of the parameter]\n\nPreconditions:\n```\n(at ?from)\n```\n\nEffects:\n```\n(and\n    (not (at ?from))\n    (at ?to)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the baking domain for demonstrating the output format.\n        \nDomain information: This describes a cooking or baking process where ingredients such as eggs and flour are used. The process of baking involves putting eggs in the pan followed by the flour, mix the two and then put the pan in the oven and then remove the pan from the oven to get the baked cake. Lastly, the pan is cleaned using a soap. Well, you can also bake a souffle but in at bit different process.\n\nA list of available predicates\n1. (is_egg ?egg - ingredient) ;; the ingredient is an egg\n2. (is_flour ?flour - ingredient) ;; the ingredient is flour\n3. (pan_has_egg ?pan - pan) ;; the pan has an egg\n4. (pan_has_flour ?pan - pan) ;; the pan has flour\n5. (pan_is_clean ?pan - pan) ;; the pan is clean\n6. (pan_in_oven ?pan - pan) ;; the pan is in the oven\n7. (in_pan ?x - ingredient ?pan - pan) ;; the ingredient is in the pan\n8. (in_oven ?pan - pan ?oven - oven) ;; the pan is in the oven\n9. (oven_is_full ?oven - oven) ;; the oven is full\n10. (hypothetical ?new - ingredient) ;; the ingredient is hypothetical\n11. (is_mixed ?pan - pan) ;; the ingredients in the pan are mixed\n12. (is_cake ?new - ingredient) ;; the ingredient is a cake\n13. (is_souffle ?new - ingredient) ;; the ingredient is a souffle\n14. (soap_consumed ?soap - soap) ;; the soap is consumed\nExample 1\nAction Description: This action represents the process of making a souffle. It requires an egg in a pan (without flour), with the pan placed in an oven. A new, hypothetical ingredient is involved, which becomes a souffle as a result of this process. After baking, the pan is no longer clean.\n\nAction name: bake_souffle\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of making a souffle as if it were a little project where you need certain things to start, and you end up with something new at the end. In our souffle-making scenario, you begin with a pan, an egg, and an oven. This matches closely with our action schema in PDDL, named `bake_souffle`.\n\n1. **Preconditions:** \n    - **Egg in the Pan:** To make a souffle, the first thing you need is an egg in the pan. This matches the precondition `(in_pan ?egg ?pan)`, meaning the egg needs to be in the pan to start.\n    - **The Egg is Really an Egg:** We also need to confirm that what we're using is indeed an egg, so we check `(is_egg ?egg)`.\n    - **No Flour in the Pan:** For this particular recipe, having flour in the pan would mess things up, so the precondition `(not (pan_has_flour ?pan))` ensures flour isn't in the pan.\n    - **Pan in the Oven:** The pan must be in the oven `(in_oven ?pan ?oven)` for the baking to occur.\n    - **Hypothetical New Ingredient:** The schema mentions a `hypothetical ?new`, which represents the potential new ingredient, the souffle, that will be created.\n\n2. **Effects:**\n    - **Egg Transforms into Souffle:** After baking, the egg isn't just an egg anymore; it becomes a souffle. This is shown by `(not (is_egg ?egg))` and `(is_souffle ?new)`, where the egg disappears as an egg and reappears as a souffle.\n    - **Pan is No Longer Clean:** Baking usually leaves the pan dirty. Thus, the effect `(not (pan_is_clean ?pan))` captures this change.\n    - **Ingredients and Conditions Reset:** The egg is no longer in the pan, shown by `(not (in_pan ?egg ?pan))` and `(not (pan_has_egg ?pan))`, and the hypothetical nature of the new ingredient is removed with `(not (hypothetical ?new))`, finalizing the souffle's existence.\n\nSo, we start with an egg in a clean pan and finish with a baked souffle and a dirty pan. This schema captures all the steps and checks needed to go from start to finish in the souffle-making process, ensuring that each step and condition is accounted for, just like following a recipe!\n                \n**Response:**\nParameters:\n1. ?oven - oven: [short description of the parameter]\n2. ?egg - ingredient: [short description of the parameter]\n3. ?pan - pan: [short description of the parameter]\n4. ?new - ingredient: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (in_pan ?egg ?pan)\n    (is_egg ?egg)\n    (not (pan_has_flour ?pan))\n    (in_oven ?pan ?oven)\n    (hypothetical ?new)\n)\n```\n\nEffects:\n```\n(and\n    (not (is_egg ?egg))\n    (not (in_pan ?egg ?pan))\n    (not (pan_has_egg ?pan))\n    (not (pan_is_clean ?pan))\n    (not (hypothetical ?new))\n    (is_souffle ?new)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: This action is about taking a pan out of the oven. It can only be done if the pan is actually in the oven. Once the pan is removed, the oven is no longer considered full.\n\nAction name: remove_pan_from_oven\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Let's break down this action of removing a pan from the oven in a simple way.\n\nImagine you're baking a cake and you put your pan in the oven. Now, the oven is full because the pan is inside. At some point, you need to take the pan out of the oven when the cake is done. \n\nTo do this action of removing the pan, we need to make sure that the pan is actually in the oven first. This is the \"precondition\" \u2013 it's like a rule saying, \"You can only take the pan out if it's actually in there.\" It wouldn't make sense to try to take out a pan that isn't in the oven, right?\n\nOnce you take the pan out, several things happen, which we call \"effects\":\n1. The oven is no longer full because the pan is out.\n2. The pan is no longer in the oven.\n3. We also need to specifically say that the pan is not in the oven anymore.\n\nSo, the precondition (the rule that the pan must be in the oven) makes sure we can only do this action when it's appropriate. The effects describe what changes after we do the action. In this case, the oven is no longer full, and the pan is no longer in the oven. This helps us keep track of what's happening in our cooking process in a clear and logical way.\n                \n**Response:**\nParameters:\n1. ?pan - pan: [short description of the parameter]\n2. ?oven - oven: [short description of the parameter]\n\nPreconditions:\n```\n(in_oven ?pan ?oven)\n```\n\nEffects:\n```\n(and\n    (not (oven_is_full ?oven))\n    (not (in_oven ?pan ?oven))\n    (not (pan_in_oven ?pan))\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: Help the hero to get out of dungeon! A hero woke up in a dungeon full of monsters and traps (perhaps the party last night went wrong...) and needs your help to get out.  Here are basic facts for the dungeon domain: - The dungeon contains rooms that are **connected** by corridors (dungeon can thus be represented by undirected graph) - each room can be **empty**, or can have a **monster** in it, or can have a **trap** in it, or can have a **sword** in it - one of the empty rooms is the **goal**: it has an exit, so the hero can escape\n\nA list of available predicates\n1. (at-hero ?loc - cells) ;;  Hero's cell location\n2. (at-sword ?s - swords ?loc - cells) ;; Sword cell location\n3. (has-monster ?loc - cells) ;; Indicates if a cell location has a monster\n4. (has-trap ?loc - cells) ;; Indicates if a cell location has a trap\n5. (is-destroyed ?obj) ;; Indicates if a chell or sword has been destroyed\n6. (connected ?from ?to - cells) ;; connects cells\n7. (arm-free) ;; Hero's hand is free\n8. (holding ?s - swords) ;; Hero's holding a sword\n9. (trap-disarmed ?loc) ;; It becomes true when a trap is disarmed\n\nAction Description: Hero can move if the - hero is at current location - cells are connected, - there is no trap in current loc, and - destination does not have a trap/monster/has-been-destroyed Effects move the hero, and destroy the original cell. No need to destroy the sword.\n\nAction name: move\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the given dungeon domain, the hero needs to navigate through rooms connected by corridors to find an exit. The action \"move\" is a fundamental part of this navigation process. For the hero to successfully move from one room to another, certain conditions must be met, and certain outcomes will result from this action.\n\nThe **preconditions** for the \"move\" action ensure that the hero can only move if:\n- The hero is currently at a specific location (`at-hero ?from`).\n- The current location and the destination are connected (`connected ?from ?to`).\n- There is no trap in the current location (`not (has-trap ?from)`).\n- The destination is not occupied by a monster, does not have a trap, and has not been destroyed (`not (has-monster ?to)`, `not (has-trap ?to)`, `not (is-destroyed ?to)`).\n\nThe **effects** of the \"move\" action are:\n- The hero is no longer at the original location (`not (at-hero ?from)`).\n- The hero is now at the new location (`at-hero ?to`).\n- The original location is destroyed (`is-destroyed ?from`), but the sword, if present, remains undestroyed.\n\nThis action schema allows the hero to progress through the dungeon by moving from one safe room to another until the exit is reached.\n\n**Response:**\nParameters:\n1. ?from - cells: [The cell location where the hero is currently at]\n2. ?to - cells: [The cell location where the hero wants to move to]\n\nPreconditions:\n```\n(and\n    (at-hero ?from)\n    (connected ?from ?to)\n    (not (has-trap ?from))\n    (not (has-monster ?to))\n    (not (has-trap ?to))\n    (not (is-destroyed ?to))\n)\n```\n\nEffects:\n```\n(and\n    (not (at-hero ?from))\n    (at-hero ?to)\n    (is-destroyed ?from)\n)\n```\n\n---", "type": "response", "action": "move"}
