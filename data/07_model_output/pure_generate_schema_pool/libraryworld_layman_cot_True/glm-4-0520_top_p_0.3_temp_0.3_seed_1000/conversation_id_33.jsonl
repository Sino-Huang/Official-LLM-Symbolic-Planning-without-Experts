{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the barman domain for demonstrating the output format.\n        \nDomain information: In this domain there is a robot barman that manipulates drink dispensers, glasses and a shaker. The goal is to find a plan of the robots actions that serves a desired set of drinks. In this domain deletes of actions encode relevant knowledge given that robot hands can only grasp one object at a time and given that glasses need to be empty and clean to be filled.\n\nA list of available predicates\n1. (ontable ?c - container) ;; the container is on the table\n2. (holding ?h - hand ?c - container) ;; the hand is holding the container\n3. (handempty ?h - hand) ;; the hand is empty\n4. (empty ?c - container) ;; the container is empty\n5. (contains ?c - container ?b - beverage) ;; the container contains the beverage\n6. (clean ?c - container) ;; the container is clean\n7. (used ?c - container ?b - beverage) ;; the container is used for the beverage\n8. (dispenses ?d - dispenser ?i - ingredient) ;; the dispenser dispenses the ingredient\n9. (shaker-empty-level ?s - shaker ?l - level) ;; the empty level of the shaker\n10. (shaker-level ?s - shaker ?l - level) ;; the shaker currently is at the level\n11. (next ?l1 ?l2 - level) ;; l2 is the next level after l1\n12. (unshaked ?s - shaker) ;; the shaker is unshaked\n13. (shaked ?s - shaker) ;; the shaker is shaked\n14. (cocktail-part1 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\n15. (cocktail-part2 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\nExample 1\nAction Description: Similar to the previous action, but the shaker already contains ingredients and isn't clean.\n\nAction name: pour-shot-to-used-shaker\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you have a robot bartender who's trying to make a drink using a shaker that already has some ingredients but hasn't been cleaned. To help the robot make the drink correctly, we need to give it a clear set of instructions. These instructions are what we call an action schema in PDDL, a planning language.\n\nLet's break down the action called \"pour-shot-to-used-shaker\":\n\n1. **Preconditions**: These are like the 'rules' or requirements that must be true before the robot can start the action.\n   - `(holding ?h1 ?s)`: The robot must be holding a shot glass (`?s`). Think of it like needing to hold a lemon before you can squeeze it.\n   - `(contains ?s ?i)`: The shot glass should have some ingredient (`?i`) in it. This is like saying the lemon needs to actually have juice.\n   - `(unshaked ?d)`: The shaker (`?d`) hasn't been shaken yet. It's like having a mixing bowl where the ingredients are still not mixed.\n   - `(shaker-level ?d ?l)`: The shaker is at a certain fullness level (`?l`), which tells us how much space is left or how full it is.\n   - `(next ?l ?l1)`: There's a next level (`?l1`) that the shaker will reach after pouring in the shot. It\u2019s similar to knowing that if you add one cup of flour to a half-full bowl, it will be three-quarters full.\n\n2. **Effects**: These are the changes that happen because of the action.\n   - `(not (contains ?s ?i))` and `(empty ?s)`: The shot glass will no longer contain the ingredient, and it will be empty. It\u2019s like pouring out all the lemon juice, leaving the lemon empty.\n   - `(contains ?d ?i)`: The shaker will now contain the ingredient from the shot glass. This is moving the lemon juice into the mixing bowl.\n   - `(not (shaker-level ?d ?l))` and `(shaker-level ?d ?l1)`: The shaker's level changes from the current level to the next. Just like adding the flour to the bowl changes its fullness.\n\nBy following these instructions, the robot knows exactly what needs to be true before starting (preconditions) and what changes to expect after it completes the action (effects). \n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?i - ingredient: [short description of the parameter]\n3. ?d - shaker: [short description of the parameter]\n4. ?h1 - hand: [short description of the parameter]\n5. ?l - level: [short description of the parameter]\n6. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (contains ?s ?i)\n    (unshaked ?d)\n    (shaker-level ?d ?l)\n    (next ?l ?l1)\n)\n```\n\nEffects:\n```\n(and\n    (not (contains ?s ?i))\n    (contains ?d ?i)\n    (empty ?s)\n    (not (shaker-level ?d ?l))\n    (shaker-level ?d ?l1)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The robot pours a beverage from a shaker into an empty, clean shot glass.\n\nAction name: pour-shaker-to-shot\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\nImagine you're teaching a robot how to serve drinks at a party. The robot is designed to perform specific tasks with clear instructions, much like following a recipe step-by-step.\n\n**Scenario:** The robot needs to pour a beverage from a shaker into a shot glass. The action it must perform is called \"pour-shaker-to-shot.\"\n\n**Why the Preconditions are Necessary:**\n1. **Holding the Shaker:** The robot must be holding the shaker to pour from it. If it's not holding it, it can't control the pouring process.\n2. **Shaker is Shaken:** The contents in the shaker need to be mixed well (shaken) before serving. This ensures the drink's quality and consistency.\n3. **The Shot Glass is Empty:** The glass must be empty because pouring into an already full or partially filled glass would cause a spill or mix drinks unintentionally.\n4. **The Shot Glass is Clean:** Hygiene and taste! No one wants a dirty glass, and leftover residues could alter the flavor of the new drink.\n5. **Shaker Contains the Beverage:** The robot needs to confirm that the right beverage is in the shaker to pour the correct drink.\n6. **Shaker Level is Correct:** Knowing the current level helps manage how much is poured, ensuring the robot doesn't try to pour more than what is available.\n7. **Next Level Indicator:** This indicates how much beverage will remain in the shaker after pouring, helping in planning the next steps or refilling.\n\n**How the Preconditions Lead to the Specified Effects:**\n- After the robot pours, the shot glass will no longer be clean and empty because it now contains the beverage.\n- The level of the beverage in the shaker decreases as it has been transferred to the glass.\n- The robot updates the shaker's level to reflect the new quantity, which is crucial for knowing how much is left for the next drink.\n\n**Simple Analogy:**\nThink of it like pouring apple juice for a kid. You need to make sure you have the juice (in a jug), a clean and empty cup to pour into, and you need to be holding the jug. After pouring, the cup will have juice, and there'll be less juice in the jug. Just like you need to check these things, so does the robot!\n\nBy setting up these instructions in the action \"pour-shaker-to-shot,\" we ensure the robot does its job correctly and efficiently, just like you'd carefully prepare a drink for a guest.\n                \n**Response:**\nParameters:\n1. ?b - beverage: [short description of the parameter]\n2. ?d - shot: [short description of the parameter]\n3. ?h - hand: [short description of the parameter]\n4. ?s - shaker: [short description of the parameter]\n5. ?l - level: [short description of the parameter]\n6. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h ?s)\n    (shaked ?s)\n    (empty ?d)\n    (clean ?d)\n    (contains ?s ?b)\n    (shaker-level ?s ?l)\n    (next ?l1 ?l)\n)\n```\n\nEffects:\n```\n(and\n    (not (clean ?d))\n    (not (empty ?d))\n    (contains ?d ?b)\n    (shaker-level ?s ?l1)\n    (not (shaker-level ?s ?l))\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: This domain is structured to allow organizing and managing books within a library setting. The actions and predicates support the movement of books between tables and shelves, ensuring that conditions like accessibility and the librarian's hands being free are met. Additionally, it includes managing book categories, shelf space, and check-out/return processes to reflect a more complex library system.\n\nA list of available predicates\n1. (on-shelf ?x ?y - book) ;; ?x is on top of ?y on the shelf\n2. (on-table ?x - book) ;; ?x is on the table\n3. (accessible ?x - book) ;; ?x is accessible (not covered)\n4. (hands-free) ;; The hands of the librarian are free\n5. (holding ?x - book) ;; The librarian is holding ?x\n6. (belongs-to-category ?x - book ?cat - category) ;; ?x belongs to the category ?cat\n7. (shelf-empty ?cat - category) ;; The shelf for category ?cat is empty\n8. (shelf-overflow ?cat - category) ;; The shelf for category ?cat is full\n9. (book-request ?book - book) ;; There is a request for book ?book\n10. (return-due ?book - book) ;; Book ?book is due for return\n11. (checked-out ?book - book) ;; Book ?book is checked out\n\nAction Description: Pick up a book from the table if it's not covered and your hands are empty.\n\nAction name: take-from-table\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the context of a library, the action \"take-from-table\" involves a librarian picking up a book from a table. This action is only feasible under certain conditions to ensure the book can be moved safely and efficiently. The PDDL action schema will define these conditions as preconditions and the resulting state changes as effects.\n\nThe preconditions for \"take-from-table\" ensure that the librarian can physically pick up the book:\n- The book must be on the table and not on a shelf or in another location.\n- The book must be accessible, meaning it's not covered by another book or object, allowing the librarian to pick it up without any obstacles.\n- The librarian's hands must be free, indicating that they are not currently holding another book or engaged in another task that requires the use of their hands.\n\nOnce the action is executed, the effects describe the changes in the state of the library system:\n- The book is no longer on the table since it has been picked up.\n- The librarian is now holding the book, which means their hands are no longer free.\n\nThis action schema helps the librarian system understand when it is appropriate to perform the \"take-from-table\" action and what the consequences of that action are.\n\n**Response:**\nParameters:\n1. ?book - book: [Identifies the book to be picked up from the table]\n\nPreconditions:\n```\n(and\n    (on-table ?book)\n    (accessible ?book)\n    (hands-free)\n)\n```\n\nEffects:\n```\n(and\n    (not (on-table ?book))\n    (not (hands-free))\n    (holding ?book)\n)\n```", "type": "response", "action": "take-from-table"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the barman domain for demonstrating the output format.\n        \nDomain information: In this domain there is a robot barman that manipulates drink dispensers, glasses and a shaker. The goal is to find a plan of the robots actions that serves a desired set of drinks. In this domain deletes of actions encode relevant knowledge given that robot hands can only grasp one object at a time and given that glasses need to be empty and clean to be filled.\n\nA list of available predicates\n1. (ontable ?c - container) ;; the container is on the table\n2. (holding ?h - hand ?c - container) ;; the hand is holding the container\n3. (handempty ?h - hand) ;; the hand is empty\n4. (empty ?c - container) ;; the container is empty\n5. (contains ?c - container ?b - beverage) ;; the container contains the beverage\n6. (clean ?c - container) ;; the container is clean\n7. (used ?c - container ?b - beverage) ;; the container is used for the beverage\n8. (dispenses ?d - dispenser ?i - ingredient) ;; the dispenser dispenses the ingredient\n9. (shaker-empty-level ?s - shaker ?l - level) ;; the empty level of the shaker\n10. (shaker-level ?s - shaker ?l - level) ;; the shaker currently is at the level\n11. (next ?l1 ?l2 - level) ;; l2 is the next level after l1\n12. (unshaked ?s - shaker) ;; the shaker is unshaked\n13. (shaked ?s - shaker) ;; the shaker is shaked\n14. (cocktail-part1 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\n15. (cocktail-part2 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\nExample 1\nAction Description: The robot empties a shaker that has been shaken, changing its level.\n\nAction name: empty-shaker\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of our robot barman as someone working in a kitchen, trying to prepare a cocktail using a shaker. The robot needs to follow certain steps to make sure everything goes smoothly and safely, just like following a recipe.\n\nThe action \"empty-shaker\" is all about the robot taking a shaker that has already been shaken (which means the ingredients are mixed up properly) and emptying it out so that the drink can be served, and the shaker is ready to be cleaned and used again.\n\nNow, let's talk about the preconditions, which are like the 'must-haves' before the robot can start this action:\n1. **(holding ?h ?s)** - The robot must be holding the shaker. It can\u2019t empty it if it\u2019s not holding it, right? Just like you can't pour milk from a jug if you're not holding it.\n2. **(contains ?s ?b)** - The shaker needs to have a drink inside. There's no point in trying to empty something that's already empty.\n3. **(shaked ?s)** - The drink inside the shaker must be mixed up by shaking. This ensures the drink is ready to be served.\n4. **(shaker-level ?s ?l)** - This tells us how much drink is currently in the shaker. It\u2019s important to know this so the robot knows it\u2019s actually pouring something out.\n5. **(shaker-empty-level ?s ?l1)** - This indicates what the level of the shaker should be after emptying it. Usually, it means it will be empty or nearly empty.\n\nThe effects of the action describe what changes after the robot empties the shaker:\n1. **(not (shaked ?s))** - The shaker is no longer considered 'shaken' because it's been emptied.\n2. **(not (shaker-level ?s ?l))** - The previous level of the drink is no longer relevant because it's been poured out.\n3. **(shaker-level ?s ?l1)** - This updates the level of the shaker to show it's now empty or at the lower level expected.\n4. **(not (contains ?s ?b))** - The shaker no longer contains the drink because it\u2019s been poured out.\n5. **(empty ?s)** - Finally, the shaker is empty, ready to be washed and used again for the next drink.\n\nBy ensuring all these preconditions are met before the action and then updating everything as described in the effects, the robot efficiently manages its tasks without any mix-ups or errors, just like a good cook keeps their kitchen in order. This process helps the robot move smoothly from one task to the next, ensuring each drink is made and served perfectly.\n                \n**Response:**\nParameters:\n1. ?h - hand: [short description of the parameter]\n2. ?c - container: [short description of the parameter]\n\nPreconditions:\n```\n(holding ?h ?c)\n```\n\nEffects:\n```\n(and\n    (not (holding ?h ?c))\n    (handempty ?h)\n    (ontable ?c)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The robot places a container it's holding back onto the table.\n\nAction name: leave\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're teaching a robot barman to place a glass back on the table. The robot needs clear steps to follow, just like a recipe in cooking. In this scenario, the robot's task, or \"action,\" is named \"leave.\" Here's why the specific steps (preconditions and effects) in the action make sense:\n\n1. **Precondition (holding ?h ?c):** Before the robot can place the container on the table, it must be holding it. This is just like needing to pick up a plate before you can move it to another part of the kitchen. In the robot's instructions, this is expressed as \"(holding ?h ?c),\" meaning the robot's hand (?h) is currently holding the container (?c). This step ensures the robot knows it has the container and is ready to put it down.\n\n2. **Effects of the Action:**\n   - **(not (holding ?h ?c)):** This tells the robot to stop holding the container. It's like saying, \"Okay, you can let go of the plate now.\"\n   - **(handempty ?h):** Once the robot lets go of the container, its hand is empty. This is similar to you dropping something off and having your hand free again.\n   - **(ontable ?c):** Finally, the container ends up back on the table. This part of the instruction confirms that the container should now be on the table, just like setting a cup down on a counter.\n\nThis action schema is crafted so that the robot successfully completes the task of putting the container down in a way that makes sense step-by-step. The preconditions make sure the robot is ready to perform the action (holding the container), and the effects detail exactly what happens after the action (container on table, hand empty). It's a simple, clear set of instructions for the robot to follow, ensuring it does exactly what we want without any confusion.\n                \n**Response:**\nParameters:\n1. ?h - hand: [short description of the parameter]\n2. ?s - shaker: [short description of the parameter]\n3. ?b - cocktail: [short description of the parameter]\n4. ?l - level: [short description of the parameter]\n5. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h ?s)\n    (contains ?s ?b)\n    (shaked ?s)\n    (shaker-level ?s ?l)\n    (shaker-empty-level ?s ?l1)\n)\n```\n\nEffects:\n```\n(and\n    (not (shaked ?s))\n    (not (shaker-level ?s ?l))\n    (shaker-level ?s ?l1)\n    (not (contains ?s ?b))\n    (empty ?s)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: This domain is structured to allow organizing and managing books within a library setting. The actions and predicates support the movement of books between tables and shelves, ensuring that conditions like accessibility and the librarian's hands being free are met. Additionally, it includes managing book categories, shelf space, and check-out/return processes to reflect a more complex library system.\n\nA list of available predicates\n1. (on-shelf ?x ?y - book) ;; ?x is on top of ?y on the shelf\n2. (on-table ?x - book) ;; ?x is on the table\n3. (accessible ?x - book) ;; ?x is accessible (not covered)\n4. (hands-free) ;; The hands of the librarian are free\n5. (holding ?x - book) ;; The librarian is holding ?x\n6. (belongs-to-category ?x - book ?cat - category) ;; ?x belongs to the category ?cat\n7. (shelf-empty ?cat - category) ;; The shelf for category ?cat is empty\n8. (shelf-overflow ?cat - category) ;; The shelf for category ?cat is full\n9. (book-request ?book - book) ;; There is a request for book ?book\n10. (return-due ?book - book) ;; Book ?book is due for return\n11. (checked-out ?book - book) ;; Book ?book is checked out\n\nAction Description: Put a book you're holding onto the table, making it accessible.\n\nAction name: place-on-table\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the context of a library, the action \"place-on-table\" involves a librarian placing a book they are currently holding onto a table. This action is important for managing the accessibility of books and ensuring that they are available for patrons to browse or borrow. The action must consider the current state of the librarian's hands and the location of the book.\n\nThe preconditions for this action are straightforward:\n- The librarian must be holding a book (`holding ?book`). This is a necessary condition because the action is about placing a book on the table, and you can't place a book on the table if you're not holding it.\n- The librarian's hands must be free (`hands-free`). However, this precondition is implicitly contradicted by the `holding` predicate, as holding a book implies the hands are not free. Therefore, we do not need to include `hands-free` as a precondition.\n\nThe effects of the action describe the changes that occur once the book is placed on the table:\n- The book is no longer being held by the librarian (`not (holding ?book)`), which means the librarian's hands are now free to perform other tasks.\n- The book becomes accessible (`accessible ?book`), indicating that it is now available for patrons to see or borrow.\n- The book is now on the table (`on-table ?book`), which is the physical location change that defines the action.\n\nBy defining the action with clear preconditions and effects, we ensure that the librarian performs the action only when it is logically possible and that the state of the library is updated correctly to reflect the new location of the book.\n\n**Response:**\nParameters:\n1. ?book - book: [The book that the librarian is holding and will place on the table]\n\nPreconditions:\n```\n(holding ?book)\n```\n\nEffects:\n```\n(and\n    (not (holding ?book))\n    (accessible ?book)\n    (on-table ?book)\n)\n```", "type": "response", "action": "place-on-table"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the barman domain for demonstrating the output format.\n        \nDomain information: In this domain there is a robot barman that manipulates drink dispensers, glasses and a shaker. The goal is to find a plan of the robots actions that serves a desired set of drinks. In this domain deletes of actions encode relevant knowledge given that robot hands can only grasp one object at a time and given that glasses need to be empty and clean to be filled.\n\nA list of available predicates\n1. (ontable ?c - container) ;; the container is on the table\n2. (holding ?h - hand ?c - container) ;; the hand is holding the container\n3. (handempty ?h - hand) ;; the hand is empty\n4. (empty ?c - container) ;; the container is empty\n5. (contains ?c - container ?b - beverage) ;; the container contains the beverage\n6. (clean ?c - container) ;; the container is clean\n7. (used ?c - container ?b - beverage) ;; the container is used for the beverage\n8. (dispenses ?d - dispenser ?i - ingredient) ;; the dispenser dispenses the ingredient\n9. (shaker-empty-level ?s - shaker ?l - level) ;; the empty level of the shaker\n10. (shaker-level ?s - shaker ?l - level) ;; the shaker currently is at the level\n11. (next ?l1 ?l2 - level) ;; l2 is the next level after l1\n12. (unshaked ?s - shaker) ;; the shaker is unshaked\n13. (shaked ?s - shaker) ;; the shaker is shaked\n14. (cocktail-part1 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\n15. (cocktail-part2 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\nExample 1\nAction Description: The robot shakes a shaker containing two ingredients to make a cocktail.\n\nAction name: shake\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine our robot barman has been given the task of making a cocktail by mixing two ingredients in a shaker. Now, in the world of our robot, we describe this task using something called an \"action schema\" in PDDL, which is just a way to explain step-by-step what needs to happen.\n\nHere's why each part of the action schema for \"shake\" is set up the way it is:\n\n1. **Parameters**: This includes everything the robot needs to know about before starting:\n   - The cocktail it needs to make.\n   - The two ingredients it will use.\n   - The shaker where the mixing happens.\n   - The robot's two hands.\n\n2. **Preconditions**: These are the conditions that must be true before the robot can start shaking the ingredients:\n   - The robot must be holding the shaker in one hand (`holding ?h1 ?s`).\n   - The other hand needs to be free (`handempty ?h2`) so the robot can balance or do other tasks if needed.\n   - The shaker must contain the two specific ingredients (`contains ?s ?d1` and `contains ?s ?d2`).\n   - Each ingredient must be a correct part of the cocktail (`cocktail-part1 ?b ?d1` and `cocktail-part2 ?b ?d2`).\n   - The shaker must be unshaken (`unshaked ?s`), meaning the ingredients haven't been mixed yet.\n\n3. **Effects**: These are what will happen after the robot performs the action:\n   - The shaker will no longer be unshaken; it's now shaken (`not (unshaked ?s)` and `shaked ?s`).\n   - The individual ingredients will no longer be in the shaker by themselves because they've been mixed into a cocktail (`not (contains ?s ?d1)` and `not (contains ?s ?d2)`).\n   - Now, the shaker contains the cocktail (`contains ?s ?b`).\n\nImagine our robot is like a chef following a recipe. The preconditions are like checking that you have all your ingredients and tools ready, and the effects are what you expect to see in your cooking pot after you follow the steps. This action schema helps the robot understand exactly what conditions need to be in place before it starts mixing and what changes to expect after it\u2019s done.\n\nThis way, we make sure the robot can successfully make the cocktail without any hitches, like trying to mix without holding the shaker or mixing the wrong ingredients.\n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?i - ingredient: [short description of the parameter]\n3. ?d - shaker: [short description of the parameter]\n4. ?h1 - hand: [short description of the parameter]\n5. ?l - level: [short description of the parameter]\n6. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (contains ?s ?i)\n    (unshaked ?d)\n    (shaker-level ?d ?l)\n    (next ?l ?l1)\n)\n```\n\nEffects:\n```\n(and\n    (not (contains ?s ?i))\n    (contains ?d ?i)\n    (empty ?s)\n    (not (shaker-level ?d ?l))\n    (shaker-level ?d ?l1)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: Similar to the previous action, but the shaker already contains ingredients and isn't clean.\n\nAction name: pour-shot-to-used-shaker\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you have a robot bartender who's trying to make a drink using a shaker that already has some ingredients but hasn't been cleaned. To help the robot make the drink correctly, we need to give it a clear set of instructions. These instructions are what we call an action schema in PDDL, a planning language.\n\nLet's break down the action called \"pour-shot-to-used-shaker\":\n\n1. **Preconditions**: These are like the 'rules' or requirements that must be true before the robot can start the action.\n   - `(holding ?h1 ?s)`: The robot must be holding a shot glass (`?s`). Think of it like needing to hold a lemon before you can squeeze it.\n   - `(contains ?s ?i)`: The shot glass should have some ingredient (`?i`) in it. This is like saying the lemon needs to actually have juice.\n   - `(unshaked ?d)`: The shaker (`?d`) hasn't been shaken yet. It's like having a mixing bowl where the ingredients are still not mixed.\n   - `(shaker-level ?d ?l)`: The shaker is at a certain fullness level (`?l`), which tells us how much space is left or how full it is.\n   - `(next ?l ?l1)`: There's a next level (`?l1`) that the shaker will reach after pouring in the shot. It\u2019s similar to knowing that if you add one cup of flour to a half-full bowl, it will be three-quarters full.\n\n2. **Effects**: These are the changes that happen because of the action.\n   - `(not (contains ?s ?i))` and `(empty ?s)`: The shot glass will no longer contain the ingredient, and it will be empty. It\u2019s like pouring out all the lemon juice, leaving the lemon empty.\n   - `(contains ?d ?i)`: The shaker will now contain the ingredient from the shot glass. This is moving the lemon juice into the mixing bowl.\n   - `(not (shaker-level ?d ?l))` and `(shaker-level ?d ?l1)`: The shaker's level changes from the current level to the next. Just like adding the flour to the bowl changes its fullness.\n\nBy following these instructions, the robot knows exactly what needs to be true before starting (preconditions) and what changes to expect after it completes the action (effects). \n                \n**Response:**\nParameters:\n1. ?b - cocktail: [short description of the parameter]\n2. ?d1 - ingredient: [short description of the parameter]\n3. ?d2 - ingredient: [short description of the parameter]\n4. ?s - shaker: [short description of the parameter]\n5. ?h1 - hand: [short description of the parameter]\n6. ?h2 - hand: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (handempty ?h2)\n    (contains ?s ?d1)\n    (contains ?s ?d2)\n    (cocktail-part1 ?b ?d1)\n    (cocktail-part2 ?b ?d2)\n    (unshaked ?s)\n)\n```\n\nEffects:\n```\n(and\n    (not (unshaked ?s))\n    (not (contains ?s ?d1))\n    (not (contains ?s ?d2))\n    (shaked ?s)\n    (contains ?s ?b)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery wants to deliver the newspaper to a house (loc_house1).\nRoboDelivery performs the move action to go from loc_home to loc_house1.\n\n    Preconditions: RoboDelivery is at loc_home.\n    Effects: RoboDelivery is no longer at loc_home and is now at loc_house1.\n\nAction name: move\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're playing a game where you need to deliver newspapers to different houses in your neighborhood. Each turn in the game allows you to move from one house to another. The action of moving from one house to another in the game can be compared to an action in our newspaper delivery model.\n\nIn the scenario, the action is called \"move,\" and it involves a delivery person moving from a starting location to a destination. Let's break down why this action is modeled the way it is:\n\n1. **Parameters**: These are like placeholders or markers in our game. In the \"move\" action, the parameters are the Starting Location and the Destination. It's just like saying, \"I'm starting from my house and going to my friend's house.\"\n\n2. **Preconditions**: Before you can move from one house to another, you must be at the house you're starting from. It wouldn't make sense to say, \"I'm going from my house to my friend's house\" if you're actually at the grocery store, right? So, the precondition that the delivery person is at the starting location is crucial to make the action logical.\n\n3. **Effects**: After you move from your house to your friend's house, you are no longer at your house; you are now at your friend's house. That\u2019s what happens in our model, too. The effect of the move action is that the delivery person is no longer at the starting location and is now at the destination. This change is captured in the model by removing the state of being at the starting location (`not (at ?from)`) and adding the state of being at the destination (`(at ?to)`).\n\nSo, this action schema perfectly represents the simple yet essential task of moving from one point to another, ensuring that the game's rules are followed: you start from where you say you are, and you end up where you want to go. It's just like moving pieces on a board game, ensuring each move is valid based on where you are and where you want to be.\n                \n**Response:**\nParameters:\n1. ?from - loc: [short description of the parameter]\n2. ?to - loc: [short description of the parameter]\n\nPreconditions:\n```\n(at ?from)\n```\n\nEffects:\n```\n(and\n    (not (at ?from))\n    (at ?to)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: This domain is structured to allow organizing and managing books within a library setting. The actions and predicates support the movement of books between tables and shelves, ensuring that conditions like accessibility and the librarian's hands being free are met. Additionally, it includes managing book categories, shelf space, and check-out/return processes to reflect a more complex library system.\n\nA list of available predicates\n1. (on-shelf ?x ?y - book) ;; ?x is on top of ?y on the shelf\n2. (on-table ?x - book) ;; ?x is on the table\n3. (accessible ?x - book) ;; ?x is accessible (not covered)\n4. (hands-free) ;; The hands of the librarian are free\n5. (holding ?x - book) ;; The librarian is holding ?x\n6. (belongs-to-category ?x - book ?cat - category) ;; ?x belongs to the category ?cat\n7. (shelf-empty ?cat - category) ;; The shelf for category ?cat is empty\n8. (shelf-overflow ?cat - category) ;; The shelf for category ?cat is full\n9. (book-request ?book - book) ;; There is a request for book ?book\n10. (return-due ?book - book) ;; Book ?book is due for return\n11. (checked-out ?book - book) ;; Book ?book is checked out\n\nAction Description: Put a book you're holding on top of another accessible book on the shelf.\n\nAction name: place-on-shelf\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the context of a library, the action \"place-on-shelf\" involves a librarian placing a book they are currently holding onto a shelf, specifically on top of another book that is already there. This action requires certain conditions to be met before it can be executed and results in changes to the state of the library's books and shelves.\n\nLet's break down the components of this action:\n\n1. **Parameters**: The parameters for this action include the book to be placed (`?book-to-place`), the book that will be underneath (`?book-underneath`), and the category of the shelf (`?category`).\n\n2. **Preconditions**: These are the conditions that must be true before the librarian can perform the action:\n   - `(holding ?book-to-place)`: The librarian must be holding the book that is to be placed on the shelf.\n   - `(on-shelf ?book-underneath ?category)`: The book underneath, which will support the book to be placed, must already be on the shelf and belong to the same category.\n   - `(accessible ?book-underneath)`: The book underneath must be accessible, meaning it is not covered by another book and can be used as a base for stacking another book on top.\n   - `(belongs-to-category ?book-to-place ?category)`: The book to be placed must belong to the same category as the shelf where it will be placed.\n\n3. **Effects**: These are the changes that occur as a result of the action:\n   - `(not (holding ?book-to-place))`: The librarian is no longer holding the book after placing it on the shelf.\n   - `(on-shelf ?book-to-place ?category)`: The book is now on the shelf, on top of the other book.\n   - The action does not explicitly state changes to the predicates `(hands-free)` or `(shelf-overflow ?category)`, but these may be inferred as consequences of the action. For example, placing a book on the shelf may free up the librarian's hands or potentially contribute to the shelf becoming full.\n\nThe action schema ensures that the librarian operates within the constraints of the library system, such as not placing books on top of inaccessible ones or on the wrong shelves.\n\n**Response:**\nParameters:\n1. ?book-to-place - book: [The book that the librarian is holding and will place on the shelf]\n2. ?book-underneath - book: [The book that is already on the shelf and will be underneath the placed book]\n3. ?category - category: [The category of the shelf where the book will be placed]\n\nPreconditions:\n```\n(and\n    (holding ?book-to-place)\n    (on-shelf ?book-underneath ?category)\n    (accessible ?book-underneath)\n    (belongs-to-category ?book-to-place ?category)\n)\n```\n\nEffects:\n```\n(and\n    (not (holding ?book-to-place))\n    (on-shelf ?book-to-place ?category)\n)\n```\n\n---", "type": "response", "action": "place-on-shelf"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the barman domain for demonstrating the output format.\n        \nDomain information: In this domain there is a robot barman that manipulates drink dispensers, glasses and a shaker. The goal is to find a plan of the robots actions that serves a desired set of drinks. In this domain deletes of actions encode relevant knowledge given that robot hands can only grasp one object at a time and given that glasses need to be empty and clean to be filled.\n\nA list of available predicates\n1. (ontable ?c - container) ;; the container is on the table\n2. (holding ?h - hand ?c - container) ;; the hand is holding the container\n3. (handempty ?h - hand) ;; the hand is empty\n4. (empty ?c - container) ;; the container is empty\n5. (contains ?c - container ?b - beverage) ;; the container contains the beverage\n6. (clean ?c - container) ;; the container is clean\n7. (used ?c - container ?b - beverage) ;; the container is used for the beverage\n8. (dispenses ?d - dispenser ?i - ingredient) ;; the dispenser dispenses the ingredient\n9. (shaker-empty-level ?s - shaker ?l - level) ;; the empty level of the shaker\n10. (shaker-level ?s - shaker ?l - level) ;; the shaker currently is at the level\n11. (next ?l1 ?l2 - level) ;; l2 is the next level after l1\n12. (unshaked ?s - shaker) ;; the shaker is unshaked\n13. (shaked ?s - shaker) ;; the shaker is shaked\n14. (cocktail-part1 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\n15. (cocktail-part2 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\nExample 1\nAction Description: The robot pours an ingredient from a shot glass into a clean shaker, changing its level.\n\nAction name: pour-shot-to-clean-shaker\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you have a robot bartender tasked with making a special cocktail. It has a shot glass with an ingredient and needs to transfer this into a shaker to mix the drink properly. The action we're talking about is named \"pour-shot-to-clean-shaker.\"\n\nLet's break down the steps and rules (we call these \"preconditions\" and \"effects\") for this action using a simple scenario:\n\n1. **Preconditions (the rules that must be true before the action starts):**\n   - The robot must be holding the shot glass. This makes sense because it can't pour from the shot glass if it's not holding it!\n   - The shot glass must contain the ingredient it's supposed to pour. You wouldn't pour if the glass was empty, right?\n   - The shaker, where the ingredient will go, must be empty and clean. This ensures that previous contents don't mix with the new ingredient, keeping your drink as intended.\n   - The shaker must be at a certain level of fullness before pouring, and the robot knows what level comes next. This helps in measuring how much more it can add.\n\n2. **Effects (what happens after the action is performed):**\n   - The shot glass will no longer contain the ingredient because it's been poured out.\n   - The shot glass becomes empty because all its contents have been transferred.\n   - The shaker now contains the ingredient from the shot glass.\n   - The shaker is no longer empty or clean because it has something in it now.\n   - The shaker remains unshaken; just because the ingredient is added doesn't mean it's ready to drink. Mixing is a separate step!\n   - The level of the shaker changes to the next level, accounting for the added ingredient.\n\nBy setting these preconditions and effects, the robot knows exactly what to check and what changes to make in its environment to successfully make the cocktail. This careful planning ensures the drink is made correctly and efficiently, step by step.\n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?i - ingredient: [short description of the parameter]\n3. ?d - shaker: [short description of the parameter]\n4. ?h1 - hand: [short description of the parameter]\n5. ?l - level: [short description of the parameter]\n6. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (contains ?s ?i)\n    (empty ?d)\n    (clean ?d)\n    (shaker-level ?d ?l)\n    (next ?l ?l1)\n)\n```\n\nEffects:\n```\n(and\n    (not (contains ?s ?i))\n    (empty ?s)\n    (contains ?d ?i)\n    (not (empty ?d))\n    (not (clean ?d))\n    (unshaked ?d)\n    (not (shaker-level ?d ?l))\n    (shaker-level ?d ?l1)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The robot cleans a used shot glass.\n\nAction name: clean-shot\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine our robot barman is preparing drinks in a bar where it must handle different glasses, like a shot glass. The robot needs to clean a used shot glass to make sure it's ready for the next drink. This situation leads us to create an action called `clean-shot` in the robot's planning.\n\nFirst, the robot needs to make sure it's holding the shot glass with one hand (`holding ?h1 ?s`). This makes sense because you need to hold the glass to clean it properly.\n\nNext, the robot needs to have its other hand free (`handempty ?h2`). This is important because the robot might need to use this hand to operate cleaning tools or to stabilize the glass while cleaning.\n\nThe glass itself must be empty (`empty ?s`) before it can be cleaned. Imagine trying to clean a glass while it's still full of liquid; it would be messy and ineffective!\n\nLastly, the glass should have been used (`used ?s ?b`), indicating it was previously filled with a drink and now requires cleaning. This precondition checks whether the glass actually needs cleaning.\n\nOnce all these conditions are met, the robot can proceed with the cleaning action. The effect of this action is twofold: the shot glass is no longer 'used' for the specific beverage (`not (used ?s ?b)`), and the glass becomes clean (`clean ?s`).\n\nBy setting these preconditions and effects, we ensure that the robot performs the cleaning task effectively and prepares the glass for future use, maintaining a smooth operation in the bar scenario.\n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?b - beverage: [short description of the parameter]\n3. ?h1 - hand: [short description of the parameter]\n4. ?h2 - hand: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (handempty ?h2)\n    (empty ?s)\n    (used ?s ?b)\n)\n```\n\nEffects:\n```\n(and\n    (not (used ?s ?b))\n    (clean ?s)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (wants_Paper ?loc)\n    (carrying ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (carrying ?paper))\n    (not (wants_Paper ?loc))\n    (satisfied ?loc)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The house at loc_house1 wants a newspaper.\nRoboDelivery performs the deliver action to give paper1 to the house.\n\n    Preconditions: RoboDelivery is at loc_house1, the house wants a newspaper, and RoboDelivery is carrying paper1.\n    Effects: RoboDelivery is no longer carrying paper1, the house at loc_house1 no longer wants a newspaper, and the house at loc_house1 is satisfied.\n\nAction name: deliver\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of the action of delivering a newspaper like a simple task you might do every day, like delivering a letter to your neighbor. The description given helps us understand how a delivery person can complete their job of delivering newspapers effectively in a systematic way, which is where the PDDL (a planning language) comes into play.\n\n1. **Preconditions: Why are they necessary?**\n   - The delivery person must be at the right location (`at ?loc`): Just like if you were to deliver a letter to your neighbor, you need to be at their house, not yours! This ensures the newspaper is delivered to the correct place.\n   - The delivery location wants a newspaper (`wants_Paper ?loc`): This makes sure that the delivery person is not just going around giving out newspapers to places that don't need them. It\u2019s like checking if your neighbor actually needs the letter before you walk over.\n   - The delivery person must be carrying the newspaper (`carrying ?paper`): This is pretty straightforward\u2014just as you can't deliver a letter that you don't have in your hand, the delivery person needs to have the newspaper with them to deliver it.\n\n2. **Effects: How do they follow from the preconditions?**\n   - The newspaper is no longer being carried by the delivery person (`not (carrying ?paper)`): Once the delivery is done, just like handing over a letter, the newspaper is no longer with the delivery person.\n   - The delivery location no longer wants the newspaper (`not (wants_Paper ?loc)`): The need for the newspaper has been met, similar to how your neighbor no longer waits for the letter once you've delivered it.\n   - The location is satisfied (`satisfied ?loc`): This indicates that the delivery was successful. The location got what it was waiting for, just like your neighbor feeling happy receiving the letter.\n\nIn summary, the action of delivering a newspaper in this PDDL model ensures that everything needed to complete a successful delivery is in place before the delivery starts, and once done, it updates the state to reflect the successful completion of the task. It's about making sure you have what you need, going where you need to go, and ensuring the task is completed as expected!\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: This domain is structured to allow organizing and managing books within a library setting. The actions and predicates support the movement of books between tables and shelves, ensuring that conditions like accessibility and the librarian's hands being free are met. Additionally, it includes managing book categories, shelf space, and check-out/return processes to reflect a more complex library system.\n\nA list of available predicates\n1. (on-shelf ?x ?y - book) ;; ?x is on top of ?y on the shelf\n2. (on-table ?x - book) ;; ?x is on the table\n3. (accessible ?x - book) ;; ?x is accessible (not covered)\n4. (hands-free) ;; The hands of the librarian are free\n5. (holding ?x - book) ;; The librarian is holding ?x\n6. (belongs-to-category ?x - book ?cat - category) ;; ?x belongs to the category ?cat\n7. (shelf-empty ?cat - category) ;; The shelf for category ?cat is empty\n8. (shelf-overflow ?cat - category) ;; The shelf for category ?cat is full\n9. (book-request ?book - book) ;; There is a request for book ?book\n10. (return-due ?book - book) ;; Book ?book is due for return\n11. (checked-out ?book - book) ;; Book ?book is checked out\n\nAction Description: Pick up an accessible book from the shelf if your hands are empty, making the book underneath accessible.\n\nAction name: remove-from-shelf\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the context of a library, the action of removing a book from a shelf is a common task that a librarian might perform. This action, named \"remove-from-shelf,\" involves picking up a book that is on a shelf and making the book that was underneath it accessible to others. To ensure that this action is performed correctly, we need to define the preconditions and effects in PDDL.\n\nThe preconditions for this action are:\n- The librarian's hands must be free (`hands-free`): This is a fundamental requirement because the librarian cannot pick up a book if their hands are already occupied.\n- The book to be removed must be on a shelf and accessible (`on-shelf ?book ?underneath` and `accessible ?book`): This ensures that the book is actually on the shelf and not covered by another book, making it impossible to pick up.\n\nThe effects of this action are:\n- The book that was underneath the removed book becomes accessible (`accessible ?underneath`): This is because once the book on top is removed, the one underneath it is no longer obscured.\n- The librarian is now holding the book (`holding ?book`): This reflects the change in the state of the librarian's hands, as they are now occupied with the book.\n- The book is no longer on the shelf (`not (on-shelf ?book ?underneath)`): This updates the location of the book to reflect that it has been picked up.\n\nBy defining these preconditions and effects, we ensure that the action is logically consistent and can be executed by the planning system in a way that mimics real-world library operations.\n\n**Response:**\nParameters:\n1. ?book - book: [The book to be removed from the shelf]\n2. ?underneath - book: [The book that is underneath the book to be removed]\n\nPreconditions:\n```\n(and\n    (on-shelf ?book ?underneath)\n    (accessible ?book)\n    (hands-free)\n)\n```\n\nEffects:\n```\n(and\n    (not (on-shelf ?book ?underneath))\n    (holding ?book)\n    (accessible ?underneath)\n)\n```\n\n---", "type": "response", "action": "remove-from-shelf"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the barman domain for demonstrating the output format.\n        \nDomain information: In this domain there is a robot barman that manipulates drink dispensers, glasses and a shaker. The goal is to find a plan of the robots actions that serves a desired set of drinks. In this domain deletes of actions encode relevant knowledge given that robot hands can only grasp one object at a time and given that glasses need to be empty and clean to be filled.\n\nA list of available predicates\n1. (ontable ?c - container) ;; the container is on the table\n2. (holding ?h - hand ?c - container) ;; the hand is holding the container\n3. (handempty ?h - hand) ;; the hand is empty\n4. (empty ?c - container) ;; the container is empty\n5. (contains ?c - container ?b - beverage) ;; the container contains the beverage\n6. (clean ?c - container) ;; the container is clean\n7. (used ?c - container ?b - beverage) ;; the container is used for the beverage\n8. (dispenses ?d - dispenser ?i - ingredient) ;; the dispenser dispenses the ingredient\n9. (shaker-empty-level ?s - shaker ?l - level) ;; the empty level of the shaker\n10. (shaker-level ?s - shaker ?l - level) ;; the shaker currently is at the level\n11. (next ?l1 ?l2 - level) ;; l2 is the next level after l1\n12. (unshaked ?s - shaker) ;; the shaker is unshaked\n13. (shaked ?s - shaker) ;; the shaker is shaked\n14. (cocktail-part1 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\n15. (cocktail-part2 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\nExample 1\nAction Description: The robot fills an empty, clean shot glass with an ingredient from a dispenser.\n\nAction name: fill-shot\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:** Imagine our robot barman in a kitchen where it needs to prepare a drink using a shot glass. The robot has two hands and can only use one hand to hold an item at a time. Here\u2019s why the robot needs to follow certain steps, called preconditions, before it can fill the shot glass, which is the goal of the \"fill-shot\" action.\n\nFirstly, the robot must be holding the shot glass with one hand, which we call ?h1. This is important because the robot can only fill something it is holding. The precondition `(holding ?h1 ?s)` ensures that the robot has a good grip on the shot glass before proceeding.\n\nSecondly, the other hand, ?h2, must be empty (`handempty ?h2`). This is because if the hand is already holding something else, the robot wouldn\u2019t be able to operate the dispenser properly or manage other tasks like adding more ingredients if needed.\n\nThe next precondition is that the dispenser identified as ?d must be capable of dispensing the ingredient ?i, as noted in `(dispenses ?d ?i)`. This ensures that the robot is at the right dispenser for the ingredient it needs to fill the shot glass with.\n\nAlso, the shot glass itself must be empty (`empty ?s`) and clean (`clean ?s`) before anything is poured into it. This is common sense, right? You wouldn\u2019t want to drink from a dirty or already filled glass! This makes sure the drink is clean and tastes as expected.\n\nAfter all these conditions are met, the robot can go ahead and fill the shot glass. The effects of this action include a few changes:\n- The shot glass is no longer empty (`not (empty ?s)`), meaning it now contains the ingredient.\n- The shot glass now contains the specific ingredient (`contains ?s ?i`), which is just like saying the glass now has, say, gin in it.\n- The glass is no longer clean (`not (clean ?s)`) because it now has something in it.\n- Lastly, the shot glass is marked as used for that particular ingredient (`used ?s ?i`), which helps the robot remember what has been done with that glass.\n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?i - ingredient: [short description of the parameter]\n3. ?h1 - hand: [short description of the parameter]\n4. ?h2 - hand: [short description of the parameter]\n5. ?d - dispenser: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (handempty ?h2)\n    (dispenses ?d ?i)\n    (empty ?s)\n    (clean ?s)\n)\n```\n\nEffects:\n```\n(and\n    (not (empty ?s))\n    (contains ?s ?i)\n    (not (clean ?s))\n    (used ?s ?i)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: The robot empties a shaker that has been shaken, changing its level.\n\nAction name: empty-shaker\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's think of our robot barman as someone working in a kitchen, trying to prepare a cocktail using a shaker. The robot needs to follow certain steps to make sure everything goes smoothly and safely, just like following a recipe.\n\nThe action \"empty-shaker\" is all about the robot taking a shaker that has already been shaken (which means the ingredients are mixed up properly) and emptying it out so that the drink can be served, and the shaker is ready to be cleaned and used again.\n\nNow, let's talk about the preconditions, which are like the 'must-haves' before the robot can start this action:\n1. **(holding ?h ?s)** - The robot must be holding the shaker. It can\u2019t empty it if it\u2019s not holding it, right? Just like you can't pour milk from a jug if you're not holding it.\n2. **(contains ?s ?b)** - The shaker needs to have a drink inside. There's no point in trying to empty something that's already empty.\n3. **(shaked ?s)** - The drink inside the shaker must be mixed up by shaking. This ensures the drink is ready to be served.\n4. **(shaker-level ?s ?l)** - This tells us how much drink is currently in the shaker. It\u2019s important to know this so the robot knows it\u2019s actually pouring something out.\n5. **(shaker-empty-level ?s ?l1)** - This indicates what the level of the shaker should be after emptying it. Usually, it means it will be empty or nearly empty.\n\nThe effects of the action describe what changes after the robot empties the shaker:\n1. **(not (shaked ?s))** - The shaker is no longer considered 'shaken' because it's been emptied.\n2. **(not (shaker-level ?s ?l))** - The previous level of the drink is no longer relevant because it's been poured out.\n3. **(shaker-level ?s ?l1)** - This updates the level of the shaker to show it's now empty or at the lower level expected.\n4. **(not (contains ?s ?b))** - The shaker no longer contains the drink because it\u2019s been poured out.\n5. **(empty ?s)** - Finally, the shaker is empty, ready to be washed and used again for the next drink.\n\nBy ensuring all these preconditions are met before the action and then updating everything as described in the effects, the robot efficiently manages its tasks without any mix-ups or errors, just like a good cook keeps their kitchen in order. This process helps the robot move smoothly from one task to the next, ensuring each drink is made and served perfectly.\n                \n**Response:**\nParameters:\n1. ?h - hand: [short description of the parameter]\n2. ?s - shaker: [short description of the parameter]\n3. ?b - cocktail: [short description of the parameter]\n4. ?l - level: [short description of the parameter]\n5. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h ?s)\n    (contains ?s ?b)\n    (shaked ?s)\n    (shaker-level ?s ?l)\n    (shaker-empty-level ?s ?l1)\n)\n```\n\nEffects:\n```\n(and\n    (not (shaked ?s))\n    (not (shaker-level ?s ?l))\n    (shaker-level ?s ?l1)\n    (not (contains ?s ?b))\n    (empty ?s)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery wants to deliver the newspaper to a house (loc_house1).\nRoboDelivery performs the move action to go from loc_home to loc_house1.\n\n    Preconditions: RoboDelivery is at loc_home.\n    Effects: RoboDelivery is no longer at loc_home and is now at loc_house1.\n\nAction name: move\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're playing a game where you need to deliver newspapers to different houses in your neighborhood. Each turn in the game allows you to move from one house to another. The action of moving from one house to another in the game can be compared to an action in our newspaper delivery model.\n\nIn the scenario, the action is called \"move,\" and it involves a delivery person moving from a starting location to a destination. Let's break down why this action is modeled the way it is:\n\n1. **Parameters**: These are like placeholders or markers in our game. In the \"move\" action, the parameters are the Starting Location and the Destination. It's just like saying, \"I'm starting from my house and going to my friend's house.\"\n\n2. **Preconditions**: Before you can move from one house to another, you must be at the house you're starting from. It wouldn't make sense to say, \"I'm going from my house to my friend's house\" if you're actually at the grocery store, right? So, the precondition that the delivery person is at the starting location is crucial to make the action logical.\n\n3. **Effects**: After you move from your house to your friend's house, you are no longer at your house; you are now at your friend's house. That\u2019s what happens in our model, too. The effect of the move action is that the delivery person is no longer at the starting location and is now at the destination. This change is captured in the model by removing the state of being at the starting location (`not (at ?from)`) and adding the state of being at the destination (`(at ?to)`).\n\nSo, this action schema perfectly represents the simple yet essential task of moving from one point to another, ensuring that the game's rules are followed: you start from where you say you are, and you end up where you want to go. It's just like moving pieces on a board game, ensuring each move is valid based on where you are and where you want to be.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?from - loc: [short description of the parameter]\n2. ?to - loc: [short description of the parameter]\n\nPreconditions:\n```\n(at ?from)\n```\n\nEffects:\n```\n(and\n    (not (at ?from))\n    (at ?to)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: This domain is structured to allow organizing and managing books within a library setting. The actions and predicates support the movement of books between tables and shelves, ensuring that conditions like accessibility and the librarian's hands being free are met. Additionally, it includes managing book categories, shelf space, and check-out/return processes to reflect a more complex library system.\n\nA list of available predicates\n1. (on-shelf ?x ?y - book) ;; ?x is on top of ?y on the shelf\n2. (on-table ?x - book) ;; ?x is on the table\n3. (accessible ?x - book) ;; ?x is accessible (not covered)\n4. (hands-free) ;; The hands of the librarian are free\n5. (holding ?x - book) ;; The librarian is holding ?x\n6. (belongs-to-category ?x - book ?cat - category) ;; ?x belongs to the category ?cat\n7. (shelf-empty ?cat - category) ;; The shelf for category ?cat is empty\n8. (shelf-overflow ?cat - category) ;; The shelf for category ?cat is full\n9. (book-request ?book - book) ;; There is a request for book ?book\n10. (return-due ?book - book) ;; Book ?book is due for return\n11. (checked-out ?book - book) ;; Book ?book is checked out\n\nAction Description: Mark a book as borrowed by a patron, ensuring it's not already taken.\n\nAction name: check-out\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the context of a library, the \"check-out\" action is a fundamental operation where a librarian marks a book as borrowed by a patron. This action must ensure that the book is available for borrowing, which means it should not already be checked out by someone else. Let's break down the preconditions and effects for this action:\n\nThe preconditions for the \"check-out\" action include:\n- The book must be accessible, meaning it's not covered by another book or otherwise unavailable (`(accessible ?book)`).\n- The librarian's hands must be free to handle the book (`(hands-free)`).\n- The book must not already be checked out (`(not (checked-out ?book))`).\n\nOnce these preconditions are met, the librarian can proceed with the action. The effects of the \"check-out\" action are:\n- The book is no longer just accessible; it is now checked out (`(checked-out ?book)`).\n- Since the librarian is handling the book to mark it as checked out, the librarian's hands are no longer free (`(not (hands-free))`).\n- The book is no longer on the shelf or table, as it is now with a patron (`(not (on-shelf ?book ?other-book))` and `(not (on-table ?book))`), assuming that these predicates are part of the state description when a book is checked out.\n\nNote that the exact effects regarding the book's location on the shelf or table may vary based on additional domain rules and the desired level of detail in the model. For simplicity, we're assuming that checking out a book removes it from the library's immediate inventory.\n\n**Response:**\nParameters:\n1. ?book - book: [The book to be checked out]\n\nPreconditions:\n```\n(and\n    (accessible ?book)\n    (hands-free)\n    (not (checked-out ?book))\n)\n```\n\nEffects:\n```\n(and\n    (checked-out ?book)\n    (not (hands-free))\n    (not (on-shelf ?book ?other-book)) ;; This assumes that the book is removed from the shelf\n    (not (on-table ?book)) ;; This assumes that the book is removed from the table\n)\n```\n\nPlease note that the effects related to the book's removal from the shelf or table are based on an assumption and may need to be adjusted according to the specific rules of the library domain model.", "type": "response", "action": "check-out"}
{"role": "system", "content": "# CONTEXT #\nYou are a tool called PDDL Modeling Assistant. You are a technical experts in constructing Planning Domain Definition Language (PDDL) models via the natural language context.\n# OBJECTIVE #\n* Construct parameters, preconditions and effects based on the domain information, action description and the action name.\n* All variables in the preconditions and effects must be listed in the action's parameters. This restriction helps maintain the action's scope and prevents ambiguity in the planning process.\n* Do not use predicates that are not defined in the available predicates list to construct the preconditions and effects.\n* When the natural language description is ambiguous or certain predicate changes are implied, make reasonable assumptions based on common sense to fill up the implicit predicate in the PDDL action.\n# STYLE #\nFollow the writing style of technical experts. The output can be parsed by a machine, so it is important to follow the structured format.\n# TONE #\nBe precise and concise in constructing the PDDL action. The PDDL action should be clear and unambiguous.\n# AUDIENCE #\nYour audience is someone who is trying to learn how to construct PDDL actions from natural language descriptions.\n# RESPONSE #\nThe response should be in the following format:\n---\n**Explanation:** [Your explanation here]\n\n**Response:**\nParameters:\n1. ?x - [type]: [parameter description]\n2. ...\n\nPreconditions:\n```\n(and\n    ([predicate_1] ?x)\n)\n```\n\nEffects:\n```\n(and\n    (not ([predicate_2] ?x))\n    ([predicate_2] ?x)\n    ...\n)\n```\n---\n", "type": "prompt"}
{"role": "user", "content": "One or two examples from other domains for illustrating the input and output formats.\nHere are two examples from the barman domain for demonstrating the output format.\n        \nDomain information: In this domain there is a robot barman that manipulates drink dispensers, glasses and a shaker. The goal is to find a plan of the robots actions that serves a desired set of drinks. In this domain deletes of actions encode relevant knowledge given that robot hands can only grasp one object at a time and given that glasses need to be empty and clean to be filled.\n\nA list of available predicates\n1. (ontable ?c - container) ;; the container is on the table\n2. (holding ?h - hand ?c - container) ;; the hand is holding the container\n3. (handempty ?h - hand) ;; the hand is empty\n4. (empty ?c - container) ;; the container is empty\n5. (contains ?c - container ?b - beverage) ;; the container contains the beverage\n6. (clean ?c - container) ;; the container is clean\n7. (used ?c - container ?b - beverage) ;; the container is used for the beverage\n8. (dispenses ?d - dispenser ?i - ingredient) ;; the dispenser dispenses the ingredient\n9. (shaker-empty-level ?s - shaker ?l - level) ;; the empty level of the shaker\n10. (shaker-level ?s - shaker ?l - level) ;; the shaker currently is at the level\n11. (next ?l1 ?l2 - level) ;; l2 is the next level after l1\n12. (unshaked ?s - shaker) ;; the shaker is unshaked\n13. (shaked ?s - shaker) ;; the shaker is shaked\n14. (cocktail-part1 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\n15. (cocktail-part2 ?c - cocktail ?i - ingredient) ;; the ingredient is part of the cocktail\nExample 1\nAction Description: The robot cleans a used shot glass.\n\nAction name: clean-shot\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine our robot barman is preparing drinks in a bar where it must handle different glasses, like a shot glass. The robot needs to clean a used shot glass to make sure it's ready for the next drink. This situation leads us to create an action called `clean-shot` in the robot's planning.\n\nFirst, the robot needs to make sure it's holding the shot glass with one hand (`holding ?h1 ?s`). This makes sense because you need to hold the glass to clean it properly.\n\nNext, the robot needs to have its other hand free (`handempty ?h2`). This is important because the robot might need to use this hand to operate cleaning tools or to stabilize the glass while cleaning.\n\nThe glass itself must be empty (`empty ?s`) before it can be cleaned. Imagine trying to clean a glass while it's still full of liquid; it would be messy and ineffective!\n\nLastly, the glass should have been used (`used ?s ?b`), indicating it was previously filled with a drink and now requires cleaning. This precondition checks whether the glass actually needs cleaning.\n\nOnce all these conditions are met, the robot can proceed with the cleaning action. The effect of this action is twofold: the shot glass is no longer 'used' for the specific beverage (`not (used ?s ?b)`), and the glass becomes clean (`clean ?s`).\n\nBy setting these preconditions and effects, we ensure that the robot performs the cleaning task effectively and prepares the glass for future use, maintaining a smooth operation in the bar scenario.\n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?i - ingredient: [short description of the parameter]\n3. ?d - shaker: [short description of the parameter]\n4. ?h1 - hand: [short description of the parameter]\n5. ?l - level: [short description of the parameter]\n6. ?l1 - level: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (contains ?s ?i)\n    (unshaked ?d)\n    (shaker-level ?d ?l)\n    (next ?l ?l1)\n)\n```\n\nEffects:\n```\n(and\n    (not (contains ?s ?i))\n    (contains ?d ?i)\n    (empty ?s)\n    (not (shaker-level ?d ?l))\n    (shaker-level ?d ?l1)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: Similar to the previous action, but the shaker already contains ingredients and isn't clean.\n\nAction name: pour-shot-to-used-shaker\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you have a robot bartender who's trying to make a drink using a shaker that already has some ingredients but hasn't been cleaned. To help the robot make the drink correctly, we need to give it a clear set of instructions. These instructions are what we call an action schema in PDDL, a planning language.\n\nLet's break down the action called \"pour-shot-to-used-shaker\":\n\n1. **Preconditions**: These are like the 'rules' or requirements that must be true before the robot can start the action.\n   - `(holding ?h1 ?s)`: The robot must be holding a shot glass (`?s`). Think of it like needing to hold a lemon before you can squeeze it.\n   - `(contains ?s ?i)`: The shot glass should have some ingredient (`?i`) in it. This is like saying the lemon needs to actually have juice.\n   - `(unshaked ?d)`: The shaker (`?d`) hasn't been shaken yet. It's like having a mixing bowl where the ingredients are still not mixed.\n   - `(shaker-level ?d ?l)`: The shaker is at a certain fullness level (`?l`), which tells us how much space is left or how full it is.\n   - `(next ?l ?l1)`: There's a next level (`?l1`) that the shaker will reach after pouring in the shot. It\u2019s similar to knowing that if you add one cup of flour to a half-full bowl, it will be three-quarters full.\n\n2. **Effects**: These are the changes that happen because of the action.\n   - `(not (contains ?s ?i))` and `(empty ?s)`: The shot glass will no longer contain the ingredient, and it will be empty. It\u2019s like pouring out all the lemon juice, leaving the lemon empty.\n   - `(contains ?d ?i)`: The shaker will now contain the ingredient from the shot glass. This is moving the lemon juice into the mixing bowl.\n   - `(not (shaker-level ?d ?l))` and `(shaker-level ?d ?l1)`: The shaker's level changes from the current level to the next. Just like adding the flour to the bowl changes its fullness.\n\nBy following these instructions, the robot knows exactly what needs to be true before starting (preconditions) and what changes to expect after it completes the action (effects). \n                \n**Response:**\nParameters:\n1. ?s - shot: [short description of the parameter]\n2. ?b - beverage: [short description of the parameter]\n3. ?h1 - hand: [short description of the parameter]\n4. ?h2 - hand: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (holding ?h1 ?s)\n    (handempty ?h2)\n    (empty ?s)\n    (used ?s ?b)\n)\n```\n\nEffects:\n```\n(and\n    (not (used ?s ?b))\n    (clean ?s)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Here are two examples from the newspapers domain for demonstrating the output format.\n        \nDomain information: This domain is structured to model a simple newspaper delivery system, where the main tasks involve picking up newspapers from a home base, moving to different locations, and delivering the papers to locations that require them.\n\nA list of available predicates\n1. (at ?loc - loc) ;; the agent is at loc location\n2. (is_Home_Base ?loc - loc) ;; the location is the home base\n3. (satisfied ?loc - loc) ;; the location has received the newspaper\n4. (wants_Paper ?loc - loc) ;; the location needs a newspaper\n5. (unpacked ?paper - paper) ;; the paper is unpacked\n6. (carrying ?paper - paper) ;; the agent is carrying the paper\nExample 1\nAction Description: RoboDelivery wants to deliver the newspaper to a house (loc_house1).\nRoboDelivery performs the move action to go from loc_home to loc_house1.\n\n    Preconditions: RoboDelivery is at loc_home.\n    Effects: RoboDelivery is no longer at loc_home and is now at loc_house1.\n\nAction name: move\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nImagine you're playing a game where you need to deliver newspapers to different houses in your neighborhood. Each turn in the game allows you to move from one house to another. The action of moving from one house to another in the game can be compared to an action in our newspaper delivery model.\n\nIn the scenario, the action is called \"move,\" and it involves a delivery person moving from a starting location to a destination. Let's break down why this action is modeled the way it is:\n\n1. **Parameters**: These are like placeholders or markers in our game. In the \"move\" action, the parameters are the Starting Location and the Destination. It's just like saying, \"I'm starting from my house and going to my friend's house.\"\n\n2. **Preconditions**: Before you can move from one house to another, you must be at the house you're starting from. It wouldn't make sense to say, \"I'm going from my house to my friend's house\" if you're actually at the grocery store, right? So, the precondition that the delivery person is at the starting location is crucial to make the action logical.\n\n3. **Effects**: After you move from your house to your friend's house, you are no longer at your house; you are now at your friend's house. That\u2019s what happens in our model, too. The effect of the move action is that the delivery person is no longer at the starting location and is now at the destination. This change is captured in the model by removing the state of being at the starting location (`not (at ?from)`) and adding the state of being at the destination (`(at ?to)`).\n\nSo, this action schema perfectly represents the simple yet essential task of moving from one point to another, ensuring that the game's rules are followed: you start from where you say you are, and you end up where you want to go. It's just like moving pieces on a board game, ensuring each move is valid based on where you are and where you want to be.\n                \n**Response:**\nParameters:\n1. ?paper - paper: [short description of the parameter]\n2. ?loc - loc: [short description of the parameter]\n\nPreconditions:\n```\n(and\n    (at ?loc)\n    (is_Home_Base ?loc)\n    (unpacked ?paper)\n)\n```\n\nEffects:\n```\n(and\n    (not (unpacked ?paper))\n    (carrying ?paper)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Example 2\nAction Description: RoboDelivery is at the home base (loc_home).\nThere is an unpacked newspaper (paper1) at the home base.\nRoboDelivery performs the pick-up action.\n\n    Preconditions: RoboDelivery is at loc_home (which is the home base), and paper1 is unpacked.\n    Effects: RoboDelivery is now carrying paper1, and paper1 is no longer unpacked.\n\nAction name: pick-up\n\n\nYour answer:\n---\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nLet's imagine a situation where someone, like a delivery person, needs to pick up newspapers from a place, like a home base, and deliver them to various locations. This situation can be broken down into smaller, specific steps to make it easy for a computer to understand and execute. This is where the action schema you mentioned comes into play.\n\nThe action is called \"pick-up,\" and it involves the delivery person picking up newspapers to deliver. This action is defined in a language called PDDL, which is like giving a computer a recipe to follow.\n\n1. **Parameters**: These are like ingredients in a recipe. Here, the ingredients are any newspaper (`?paper`) and a location (`?loc`), which in this scenario is the home base.\n\n2. **Preconditions**: These are conditions that must be true before the action can start. Think of it like checking if you have all your ingredients before you start cooking.\n   - `(at ?loc)`: The delivery person must be at the location specified (`?loc`). This makes sure they are actually at the home base to pick up the newspapers.\n   - `(is_Home_Base ?loc)`: The location where they are must be the home base. This is crucial because newspapers ready to be delivered are stored here.\n   - `(unpacked ?paper)`: The newspapers need to be unpacked and ready to be picked up. It ensures the newspapers are not in boxes or still bundled up, making them easy to grab and go.\n\n3. **Effects**: These describe what happens after the action is completed.\n   - `(not (unpacked ?paper))`: The newspaper is no longer in an unpacked state at the base because it has been picked up.\n   - `(carrying ?paper)`: The newspaper is now being carried by the delivery person, ready to be delivered to someone who needs it.\n\nThis schema helps the computer understand exactly what needs to happen when the \"pick-up\" action is called in the program. By specifying preconditions, we ensure the action makes sense (you can't pick up a newspaper if you're not there or if the papers aren't ready). The effects tell the computer how the world changes after the action, like the newspaper moving from being unpacked at the base to being carried for delivery.\n\nBy breaking down tasks this way, we help the computer efficiently and correctly handle tasks that seem simple to us but are quite detailed when programmed.\n                \n**Response:**\nParameters:\n1. ?from - loc: [short description of the parameter]\n2. ?to - loc: [short description of the parameter]\n\nPreconditions:\n```\n(at ?from)\n```\n\nEffects:\n```\n(and\n    (not (at ?from))\n    (at ?to)\n)\n```\n\n---\n", "type": "prompt"}
{"role": "user", "content": "Question: Here is the task.\nA natural language description of the domain\nDomain information: This domain is structured to allow organizing and managing books within a library setting. The actions and predicates support the movement of books between tables and shelves, ensuring that conditions like accessibility and the librarian's hands being free are met. Additionally, it includes managing book categories, shelf space, and check-out/return processes to reflect a more complex library system.\n\nA list of available predicates\n1. (on-shelf ?x ?y - book) ;; ?x is on top of ?y on the shelf\n2. (on-table ?x - book) ;; ?x is on the table\n3. (accessible ?x - book) ;; ?x is accessible (not covered)\n4. (hands-free) ;; The hands of the librarian are free\n5. (holding ?x - book) ;; The librarian is holding ?x\n6. (belongs-to-category ?x - book ?cat - category) ;; ?x belongs to the category ?cat\n7. (shelf-empty ?cat - category) ;; The shelf for category ?cat is empty\n8. (shelf-overflow ?cat - category) ;; The shelf for category ?cat is full\n9. (book-request ?book - book) ;; There is a request for book ?book\n10. (return-due ?book - book) ;; Book ?book is due for return\n11. (checked-out ?book - book) ;; Book ?book is checked out\n\nAction Description: Record a book as returned by a patron when you're holding it.\n\nAction name: return-book\n\n\nYour answer:\n", "type": "prompt"}
{"role": "assistant", "content": "**Explanation:**\n\nIn the context of a library, managing the return of books is a critical task. The \"return-book\" action represents the process of recording a book as returned by a patron. For this action to occur, certain conditions must be met, and certain changes must result from the action.\n\nThe librarian must be holding the book that is being returned, which is why the `(holding ?book)` precondition is necessary. This ensures that the librarian has the book in their possession before they can record it as returned.\n\nThe action of returning a book also implies that the book is no longer checked out, so the effect `(not (checked-out ?book))` is used to reflect this change in the book's status.\n\nHere's the breakdown of the action:\n\n1. **Parameters**: The parameters for this action include the book that is being returned (`?book`).\n\n2. **Preconditions**: These are the conditions that must be true before the action can take place.\n   - `(holding ?book)`: The librarian must be holding the book to return it.\n\n3. **Effects**: These are the outcomes that result from performing the action.\n   - `(not (checked-out ?book))`: The book is no longer checked out once it has been returned.\n\nThis action schema ensures that the library's system accurately reflects the status of books and that the librarian performs the return process correctly.\n\n**Response:**\nParameters:\n1. ?book - book: [The book that is being returned]\n\nPreconditions:\n```\n(holding ?book)\n```\n\nEffects:\n```\n(not (checked-out ?book))\n```\n\n---", "type": "response", "action": "return-book"}
